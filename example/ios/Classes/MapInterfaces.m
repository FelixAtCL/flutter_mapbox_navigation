// Autogenerated from Pigeon (v11.0.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#import "MapInterfaces.h"

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#if !__has_feature(objc_arc)
#error File requires ARC to be enabled.
#endif

/// Describes glyphs rasterization modes.
@implementation FLTGlyphsRasterizationModeBox
- (instancetype)initWithValue:(FLTGlyphsRasterizationMode)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Describes the map context mode.
/// We can make some optimizations if we know that the drawing context is not shared with other code.
@implementation FLTContextModeBox
- (instancetype)initWithValue:(FLTContextMode)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Describes whether to constrain the map in both axes or only vertically e.g. while panning.
@implementation FLTConstrainModeBox
- (instancetype)initWithValue:(FLTConstrainMode)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Satisfies embedding platforms that requires the viewport coordinate systems to be set according to its standards.
@implementation FLTViewportModeBox
- (instancetype)initWithValue:(FLTViewportMode)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Describes the map orientation.
@implementation FLTNorthOrientationBox
- (instancetype)initWithValue:(FLTNorthOrientation)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Options for enabling debugging features in a map.
@implementation FLTMapDebugOptionsDataBox
- (instancetype)initWithValue:(FLTMapDebugOptionsData)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Enum describing how to place view annotation relatively to geometry.
@implementation FLTViewAnnotationAnchorBox
- (instancetype)initWithValue:(FLTViewAnnotationAnchor)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Type information of the variant's content
@implementation FLTTypeBox
- (instancetype)initWithValue:(FLTType)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Describes the reason for a style package download request failure.
@implementation FLTStylePackErrorTypeBox
- (instancetype)initWithValue:(FLTStylePackErrorType)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Describes the reason for an offline request response error.
@implementation FLTResponseErrorReasonBox
- (instancetype)initWithValue:(FLTResponseErrorReason)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Describes the download state of a region.
@implementation FLTOfflineRegionDownloadStateBox
- (instancetype)initWithValue:(FLTOfflineRegionDownloadState)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Describes tile store usage modes.
@implementation FLTTileStoreUsageModeBox
- (instancetype)initWithValue:(FLTTileStoreUsageMode)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Describes the kind of a style property value.
@implementation FLTStylePropertyValueKindBox
- (instancetype)initWithValue:(FLTStylePropertyValueKind)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// HTTP defines a set of request methods to indicate the desired action to be performed for a given resource.
@implementation FLTHttpMethodBox
- (instancetype)initWithValue:(FLTHttpMethod)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Classify network types based on cost.
@implementation FLTNetworkRestrictionBox
- (instancetype)initWithValue:(FLTNetworkRestriction)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Enum which describes possible error types which could happen during HTTP request/download calls.
@implementation FLTHttpRequestErrorTypeBox
- (instancetype)initWithValue:(FLTHttpRequestErrorType)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Enum which represents different error cases which could happen during download session.
@implementation FLTDownloadErrorCodeBox
- (instancetype)initWithValue:(FLTDownloadErrorCode)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Enum representing state of download session.
@implementation FLTDownloadStateBox
- (instancetype)initWithValue:(FLTDownloadState)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Describes the tiles data domain.
@implementation FLTTileDataDomainBox
- (instancetype)initWithValue:(FLTTileDataDomain)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Describes the reason for a tile region download request failure.
@implementation FLTTileRegionErrorTypeBox
- (instancetype)initWithValue:(FLTTileRegionErrorType)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

static NSArray *wrapResult(id result, FlutterError *error) {
  if (error) {
    return @[
      error.code ?: [NSNull null], error.message ?: [NSNull null], error.details ?: [NSNull null]
    ];
  }
  return @[ result ?: [NSNull null] ];
}
static id GetNullableObjectAtIndex(NSArray *array, NSInteger key) {
  id result = array[key];
  return (result == [NSNull null]) ? nil : result;
}

@interface FLTCameraState ()
+ (FLTCameraState *)fromList:(NSArray *)list;
+ (nullable FLTCameraState *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTScreenCoordinate ()
+ (FLTScreenCoordinate *)fromList:(NSArray *)list;
+ (nullable FLTScreenCoordinate *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTCameraBoundsOptions ()
+ (FLTCameraBoundsOptions *)fromList:(NSArray *)list;
+ (nullable FLTCameraBoundsOptions *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTCameraBounds ()
+ (FLTCameraBounds *)fromList:(NSArray *)list;
+ (nullable FLTCameraBounds *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTMapAnimationOptions ()
+ (FLTMapAnimationOptions *)fromList:(NSArray *)list;
+ (nullable FLTMapAnimationOptions *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTCoordinateBounds ()
+ (FLTCoordinateBounds *)fromList:(NSArray *)list;
+ (nullable FLTCoordinateBounds *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTMapDebugOptions ()
+ (FLTMapDebugOptions *)fromList:(NSArray *)list;
+ (nullable FLTMapDebugOptions *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTGlyphsRasterizationOptions ()
+ (FLTGlyphsRasterizationOptions *)fromList:(NSArray *)list;
+ (nullable FLTGlyphsRasterizationOptions *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTMapMemoryBudgetInMegabytes ()
+ (FLTMapMemoryBudgetInMegabytes *)fromList:(NSArray *)list;
+ (nullable FLTMapMemoryBudgetInMegabytes *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTMapMemoryBudgetInTiles ()
+ (FLTMapMemoryBudgetInTiles *)fromList:(NSArray *)list;
+ (nullable FLTMapMemoryBudgetInTiles *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTMapOptions ()
+ (FLTMapOptions *)fromList:(NSArray *)list;
+ (nullable FLTMapOptions *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTScreenBox ()
+ (FLTScreenBox *)fromList:(NSArray *)list;
+ (nullable FLTScreenBox *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTCoordinateBoundsZoom ()
+ (FLTCoordinateBoundsZoom *)fromList:(NSArray *)list;
+ (nullable FLTCoordinateBoundsZoom *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTSize ()
+ (FLTSize *)fromList:(NSArray *)list;
+ (nullable FLTSize *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTLayerPosition ()
+ (FLTLayerPosition *)fromList:(NSArray *)list;
+ (nullable FLTLayerPosition *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTCameraOptions ()
+ (FLTCameraOptions *)fromList:(NSArray *)list;
+ (nullable FLTCameraOptions *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTMbxEdgeInsets ()
+ (FLTMbxEdgeInsets *)fromList:(NSArray *)list;
+ (nullable FLTMbxEdgeInsets *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTRenderedQueryOptions ()
+ (FLTRenderedQueryOptions *)fromList:(NSArray *)list;
+ (nullable FLTRenderedQueryOptions *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTSourceQueryOptions ()
+ (FLTSourceQueryOptions *)fromList:(NSArray *)list;
+ (nullable FLTSourceQueryOptions *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTFeatureExtensionValue ()
+ (FLTFeatureExtensionValue *)fromList:(NSArray *)list;
+ (nullable FLTFeatureExtensionValue *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTQueriedFeature ()
+ (FLTQueriedFeature *)fromList:(NSArray *)list;
+ (nullable FLTQueriedFeature *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTRenderedQueryGeometry ()
+ (FLTRenderedQueryGeometry *)fromList:(NSArray *)list;
+ (nullable FLTRenderedQueryGeometry *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTTransitionOptions ()
+ (FLTTransitionOptions *)fromList:(NSArray *)list;
+ (nullable FLTTransitionOptions *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTOfflineRegionGeometryDefinition ()
+ (FLTOfflineRegionGeometryDefinition *)fromList:(NSArray *)list;
+ (nullable FLTOfflineRegionGeometryDefinition *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTOfflineRegionTilePyramidDefinition ()
+ (FLTOfflineRegionTilePyramidDefinition *)fromList:(NSArray *)list;
+ (nullable FLTOfflineRegionTilePyramidDefinition *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTProjectedMeters ()
+ (FLTProjectedMeters *)fromList:(NSArray *)list;
+ (nullable FLTProjectedMeters *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTMercatorCoordinate ()
+ (FLTMercatorCoordinate *)fromList:(NSArray *)list;
+ (nullable FLTMercatorCoordinate *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTResourceOptions ()
+ (FLTResourceOptions *)fromList:(NSArray *)list;
+ (nullable FLTResourceOptions *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTStyleObjectInfo ()
+ (FLTStyleObjectInfo *)fromList:(NSArray *)list;
+ (nullable FLTStyleObjectInfo *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTMbxImage ()
+ (FLTMbxImage *)fromList:(NSArray *)list;
+ (nullable FLTMbxImage *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTImageStretches ()
+ (FLTImageStretches *)fromList:(NSArray *)list;
+ (nullable FLTImageStretches *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTImageContent ()
+ (FLTImageContent *)fromList:(NSArray *)list;
+ (nullable FLTImageContent *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTCanonicalTileID ()
+ (FLTCanonicalTileID *)fromList:(NSArray *)list;
+ (nullable FLTCanonicalTileID *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTStylePropertyValue ()
+ (FLTStylePropertyValue *)fromList:(NSArray *)list;
+ (nullable FLTStylePropertyValue *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@implementation FLTCameraState
+ (instancetype)makeWithCenter:(NSDictionary<NSString *, id> *)center
    padding:(FLTMbxEdgeInsets *)padding
    zoom:(NSNumber *)zoom
    bearing:(NSNumber *)bearing
    pitch:(NSNumber *)pitch {
  FLTCameraState* pigeonResult = [[FLTCameraState alloc] init];
  pigeonResult.center = center;
  pigeonResult.padding = padding;
  pigeonResult.zoom = zoom;
  pigeonResult.bearing = bearing;
  pigeonResult.pitch = pitch;
  return pigeonResult;
}
+ (FLTCameraState *)fromList:(NSArray *)list {
  FLTCameraState *pigeonResult = [[FLTCameraState alloc] init];
  pigeonResult.center = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.center != nil, @"");
  pigeonResult.padding = [FLTMbxEdgeInsets nullableFromList:(GetNullableObjectAtIndex(list, 1))];
  NSAssert(pigeonResult.padding != nil, @"");
  pigeonResult.zoom = GetNullableObjectAtIndex(list, 2);
  NSAssert(pigeonResult.zoom != nil, @"");
  pigeonResult.bearing = GetNullableObjectAtIndex(list, 3);
  NSAssert(pigeonResult.bearing != nil, @"");
  pigeonResult.pitch = GetNullableObjectAtIndex(list, 4);
  NSAssert(pigeonResult.pitch != nil, @"");
  return pigeonResult;
}
+ (nullable FLTCameraState *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTCameraState fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.center ?: [NSNull null]),
    (self.padding ? [self.padding toList] : [NSNull null]),
    (self.zoom ?: [NSNull null]),
    (self.bearing ?: [NSNull null]),
    (self.pitch ?: [NSNull null]),
  ];
}
@end

@implementation FLTTransitionOptions
+ (instancetype)makeWithDuration:(nullable NSNumber *)duration
    delay:(nullable NSNumber *)delay
    enablePlacementTransitions:(nullable NSNumber *)enablePlacementTransitions {
  FLTTransitionOptions* pigeonResult = [[FLTTransitionOptions alloc] init];
  pigeonResult.duration = duration;
  pigeonResult.delay = delay;
  pigeonResult.enablePlacementTransitions = enablePlacementTransitions;
  return pigeonResult;
}
+ (FLTTransitionOptions *)fromList:(NSArray *)list {
  FLTTransitionOptions *pigeonResult = [[FLTTransitionOptions alloc] init];
  pigeonResult.duration = GetNullableObjectAtIndex(list, 0);
  pigeonResult.delay = GetNullableObjectAtIndex(list, 1);
  pigeonResult.enablePlacementTransitions = GetNullableObjectAtIndex(list, 2);
  return pigeonResult;
}
+ (nullable FLTTransitionOptions *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTTransitionOptions fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.duration ?: [NSNull null]),
    (self.delay ?: [NSNull null]),
    (self.enablePlacementTransitions ?: [NSNull null]),
  ];
}
@end

@implementation FLTLayerPosition
+ (instancetype)makeWithAbove:(nullable NSString *)above
    below:(nullable NSString *)below
    at:(nullable NSNumber *)at {
  FLTLayerPosition* pigeonResult = [[FLTLayerPosition alloc] init];
  pigeonResult.above = above;
  pigeonResult.below = below;
  pigeonResult.at = at;
  return pigeonResult;
}
+ (FLTLayerPosition *)fromList:(NSArray *)list {
  FLTLayerPosition *pigeonResult = [[FLTLayerPosition alloc] init];
  pigeonResult.above = GetNullableObjectAtIndex(list, 0);
  pigeonResult.below = GetNullableObjectAtIndex(list, 1);
  pigeonResult.at = GetNullableObjectAtIndex(list, 2);
  return pigeonResult;
}
+ (nullable FLTLayerPosition *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTLayerPosition fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.above ?: [NSNull null]),
    (self.below ?: [NSNull null]),
    (self.at ?: [NSNull null]),
  ];
}
@end

@implementation FLTScreenCoordinate
+ (instancetype)makeWithX:(NSNumber *)x
    y:(NSNumber *)y {
  FLTScreenCoordinate* pigeonResult = [[FLTScreenCoordinate alloc] init];
  pigeonResult.x = x;
  pigeonResult.y = y;
  return pigeonResult;
}
+ (FLTScreenCoordinate *)fromList:(NSArray *)list {
  FLTScreenCoordinate *pigeonResult = [[FLTScreenCoordinate alloc] init];
  pigeonResult.x = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.x != nil, @"");
  pigeonResult.y = GetNullableObjectAtIndex(list, 1);
  NSAssert(pigeonResult.y != nil, @"");
  return pigeonResult;
}
+ (nullable FLTScreenCoordinate *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTScreenCoordinate fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.x ?: [NSNull null]),
    (self.y ?: [NSNull null]),
  ];
}
@end

@implementation FLTMbxEdgeInsets
+ (instancetype)makeWithTop:(NSNumber *)top
    left:(NSNumber *)left
    bottom:(NSNumber *)bottom
    right:(NSNumber *)right {
  FLTMbxEdgeInsets* pigeonResult = [[FLTMbxEdgeInsets alloc] init];
  pigeonResult.top = top;
  pigeonResult.left = left;
  pigeonResult.bottom = bottom;
  pigeonResult.right = right;
  return pigeonResult;
}
+ (FLTMbxEdgeInsets *)fromList:(NSArray *)list {
  FLTMbxEdgeInsets *pigeonResult = [[FLTMbxEdgeInsets alloc] init];
  pigeonResult.top = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.top != nil, @"");
  pigeonResult.left = GetNullableObjectAtIndex(list, 1);
  NSAssert(pigeonResult.left != nil, @"");
  pigeonResult.bottom = GetNullableObjectAtIndex(list, 2);
  NSAssert(pigeonResult.bottom != nil, @"");
  pigeonResult.right = GetNullableObjectAtIndex(list, 3);
  NSAssert(pigeonResult.right != nil, @"");
  return pigeonResult;
}
+ (nullable FLTMbxEdgeInsets *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTMbxEdgeInsets fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.top ?: [NSNull null]),
    (self.left ?: [NSNull null]),
    (self.bottom ?: [NSNull null]),
    (self.right ?: [NSNull null]),
  ];
}
@end

@implementation FLTCameraBoundsOptions
+ (instancetype)makeWithBounds:(nullable FLTCoordinateBounds *)bounds
    maxZoom:(nullable NSNumber *)maxZoom
    minZoom:(nullable NSNumber *)minZoom
    maxPitch:(nullable NSNumber *)maxPitch
    minPitch:(nullable NSNumber *)minPitch {
  FLTCameraBoundsOptions* pigeonResult = [[FLTCameraBoundsOptions alloc] init];
  pigeonResult.bounds = bounds;
  pigeonResult.maxZoom = maxZoom;
  pigeonResult.minZoom = minZoom;
  pigeonResult.maxPitch = maxPitch;
  pigeonResult.minPitch = minPitch;
  return pigeonResult;
}
+ (FLTCameraBoundsOptions *)fromList:(NSArray *)list {
  FLTCameraBoundsOptions *pigeonResult = [[FLTCameraBoundsOptions alloc] init];
  pigeonResult.bounds = [FLTCoordinateBounds nullableFromList:(GetNullableObjectAtIndex(list, 0))];
  pigeonResult.maxZoom = GetNullableObjectAtIndex(list, 1);
  pigeonResult.minZoom = GetNullableObjectAtIndex(list, 2);
  pigeonResult.maxPitch = GetNullableObjectAtIndex(list, 3);
  pigeonResult.minPitch = GetNullableObjectAtIndex(list, 4);
  return pigeonResult;
}
+ (nullable FLTCameraBoundsOptions *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTCameraBoundsOptions fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.bounds ? [self.bounds toList] : [NSNull null]),
    (self.maxZoom ?: [NSNull null]),
    (self.minZoom ?: [NSNull null]),
    (self.maxPitch ?: [NSNull null]),
    (self.minPitch ?: [NSNull null]),
  ];
}
@end

@implementation FLTCameraBounds
+ (instancetype)makeWithBounds:(FLTCoordinateBounds *)bounds
    maxZoom:(NSNumber *)maxZoom
    minZoom:(NSNumber *)minZoom
    maxPitch:(NSNumber *)maxPitch
    minPitch:(NSNumber *)minPitch {
  FLTCameraBounds* pigeonResult = [[FLTCameraBounds alloc] init];
  pigeonResult.bounds = bounds;
  pigeonResult.maxZoom = maxZoom;
  pigeonResult.minZoom = minZoom;
  pigeonResult.maxPitch = maxPitch;
  pigeonResult.minPitch = minPitch;
  return pigeonResult;
}
+ (FLTCameraBounds *)fromList:(NSArray *)list {
  FLTCameraBounds *pigeonResult = [[FLTCameraBounds alloc] init];
  pigeonResult.bounds = [FLTCoordinateBounds nullableFromList:(GetNullableObjectAtIndex(list, 0))];
  NSAssert(pigeonResult.bounds != nil, @"");
  pigeonResult.maxZoom = GetNullableObjectAtIndex(list, 1);
  NSAssert(pigeonResult.maxZoom != nil, @"");
  pigeonResult.minZoom = GetNullableObjectAtIndex(list, 2);
  NSAssert(pigeonResult.minZoom != nil, @"");
  pigeonResult.maxPitch = GetNullableObjectAtIndex(list, 3);
  NSAssert(pigeonResult.maxPitch != nil, @"");
  pigeonResult.minPitch = GetNullableObjectAtIndex(list, 4);
  NSAssert(pigeonResult.minPitch != nil, @"");
  return pigeonResult;
}
+ (nullable FLTCameraBounds *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTCameraBounds fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.bounds ? [self.bounds toList] : [NSNull null]),
    (self.maxZoom ?: [NSNull null]),
    (self.minZoom ?: [NSNull null]),
    (self.maxPitch ?: [NSNull null]),
    (self.minPitch ?: [NSNull null]),
  ];
}
@end

@implementation FLTMapAnimationOptions
+ (instancetype)makeWithDuration:(nullable NSNumber *)duration
    startDelay:(nullable NSNumber *)startDelay {
  FLTMapAnimationOptions* pigeonResult = [[FLTMapAnimationOptions alloc] init];
  pigeonResult.duration = duration;
  pigeonResult.startDelay = startDelay;
  return pigeonResult;
}
+ (FLTMapAnimationOptions *)fromList:(NSArray *)list {
  FLTMapAnimationOptions *pigeonResult = [[FLTMapAnimationOptions alloc] init];
  pigeonResult.duration = GetNullableObjectAtIndex(list, 0);
  pigeonResult.startDelay = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable FLTMapAnimationOptions *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTMapAnimationOptions fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.duration ?: [NSNull null]),
    (self.startDelay ?: [NSNull null]),
  ];
}
@end

@implementation FLTCoordinateBounds
+ (instancetype)makeWithSouthwest:(NSDictionary<NSString *, id> *)southwest
    northeast:(NSDictionary<NSString *, id> *)northeast
    infiniteBounds:(NSNumber *)infiniteBounds {
  FLTCoordinateBounds* pigeonResult = [[FLTCoordinateBounds alloc] init];
  pigeonResult.southwest = southwest;
  pigeonResult.northeast = northeast;
  pigeonResult.infiniteBounds = infiniteBounds;
  return pigeonResult;
}
+ (FLTCoordinateBounds *)fromList:(NSArray *)list {
  FLTCoordinateBounds *pigeonResult = [[FLTCoordinateBounds alloc] init];
  pigeonResult.southwest = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.southwest != nil, @"");
  pigeonResult.northeast = GetNullableObjectAtIndex(list, 1);
  NSAssert(pigeonResult.northeast != nil, @"");
  pigeonResult.infiniteBounds = GetNullableObjectAtIndex(list, 2);
  NSAssert(pigeonResult.infiniteBounds != nil, @"");
  return pigeonResult;
}
+ (nullable FLTCoordinateBounds *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTCoordinateBounds fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.southwest ?: [NSNull null]),
    (self.northeast ?: [NSNull null]),
    (self.infiniteBounds ?: [NSNull null]),
  ];
}
@end

@implementation FLTMapDebugOptions
+ (instancetype)makeWithData:(FLTMapDebugOptionsData)data {
  FLTMapDebugOptions* pigeonResult = [[FLTMapDebugOptions alloc] init];
  pigeonResult.data = data;
  return pigeonResult;
}
+ (FLTMapDebugOptions *)fromList:(NSArray *)list {
  FLTMapDebugOptions *pigeonResult = [[FLTMapDebugOptions alloc] init];
  pigeonResult.data = [GetNullableObjectAtIndex(list, 0) integerValue];
  return pigeonResult;
}
+ (nullable FLTMapDebugOptions *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTMapDebugOptions fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.data),
  ];
}
@end

@implementation FLTGlyphsRasterizationOptions
+ (instancetype)makeWithRasterizationMode:(FLTGlyphsRasterizationMode)rasterizationMode
    fontFamily:(nullable NSString *)fontFamily {
  FLTGlyphsRasterizationOptions* pigeonResult = [[FLTGlyphsRasterizationOptions alloc] init];
  pigeonResult.rasterizationMode = rasterizationMode;
  pigeonResult.fontFamily = fontFamily;
  return pigeonResult;
}
+ (FLTGlyphsRasterizationOptions *)fromList:(NSArray *)list {
  FLTGlyphsRasterizationOptions *pigeonResult = [[FLTGlyphsRasterizationOptions alloc] init];
  pigeonResult.rasterizationMode = [GetNullableObjectAtIndex(list, 0) integerValue];
  pigeonResult.fontFamily = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable FLTGlyphsRasterizationOptions *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTGlyphsRasterizationOptions fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.rasterizationMode),
    (self.fontFamily ?: [NSNull null]),
  ];
}
@end

@implementation FLTCameraOptions
+ (instancetype)makeWithCenter:(nullable NSDictionary<NSString *, id> *)center
    padding:(nullable FLTMbxEdgeInsets *)padding
    anchor:(nullable FLTScreenCoordinate *)anchor
    zoom:(nullable NSNumber *)zoom
    bearing:(nullable NSNumber *)bearing
    pitch:(nullable NSNumber *)pitch {
  FLTCameraOptions* pigeonResult = [[FLTCameraOptions alloc] init];
  pigeonResult.center = center;
  pigeonResult.padding = padding;
  pigeonResult.anchor = anchor;
  pigeonResult.zoom = zoom;
  pigeonResult.bearing = bearing;
  pigeonResult.pitch = pitch;
  return pigeonResult;
}
+ (FLTCameraOptions *)fromList:(NSArray *)list {
  FLTCameraOptions *pigeonResult = [[FLTCameraOptions alloc] init];
  pigeonResult.center = GetNullableObjectAtIndex(list, 0);
  pigeonResult.padding = [FLTMbxEdgeInsets nullableFromList:(GetNullableObjectAtIndex(list, 1))];
  pigeonResult.anchor = [FLTScreenCoordinate nullableFromList:(GetNullableObjectAtIndex(list, 2))];
  pigeonResult.zoom = GetNullableObjectAtIndex(list, 3);
  pigeonResult.bearing = GetNullableObjectAtIndex(list, 4);
  pigeonResult.pitch = GetNullableObjectAtIndex(list, 5);
  return pigeonResult;
}
+ (nullable FLTCameraOptions *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTCameraOptions fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.center ?: [NSNull null]),
    (self.padding ? [self.padding toList] : [NSNull null]),
    (self.anchor ? [self.anchor toList] : [NSNull null]),
    (self.zoom ?: [NSNull null]),
    (self.bearing ?: [NSNull null]),
    (self.pitch ?: [NSNull null]),
  ];
}
@end

@implementation FLTMapMemoryBudgetInMegabytes
+ (instancetype)makeWithSize:(NSNumber *)size {
  FLTMapMemoryBudgetInMegabytes* pigeonResult = [[FLTMapMemoryBudgetInMegabytes alloc] init];
  pigeonResult.size = size;
  return pigeonResult;
}
+ (FLTMapMemoryBudgetInMegabytes *)fromList:(NSArray *)list {
  FLTMapMemoryBudgetInMegabytes *pigeonResult = [[FLTMapMemoryBudgetInMegabytes alloc] init];
  pigeonResult.size = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.size != nil, @"");
  return pigeonResult;
}
+ (nullable FLTMapMemoryBudgetInMegabytes *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTMapMemoryBudgetInMegabytes fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.size ?: [NSNull null]),
  ];
}
@end

@implementation FLTMapMemoryBudgetInTiles
+ (instancetype)makeWithSize:(NSNumber *)size {
  FLTMapMemoryBudgetInTiles* pigeonResult = [[FLTMapMemoryBudgetInTiles alloc] init];
  pigeonResult.size = size;
  return pigeonResult;
}
+ (FLTMapMemoryBudgetInTiles *)fromList:(NSArray *)list {
  FLTMapMemoryBudgetInTiles *pigeonResult = [[FLTMapMemoryBudgetInTiles alloc] init];
  pigeonResult.size = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.size != nil, @"");
  return pigeonResult;
}
+ (nullable FLTMapMemoryBudgetInTiles *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTMapMemoryBudgetInTiles fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.size ?: [NSNull null]),
  ];
}
@end

@implementation FLTMapOptions
+ (instancetype)makeWithContextMode:(nullable FLTContextModeBox *)contextMode
    constrainMode:(nullable FLTConstrainModeBox *)constrainMode
    viewportMode:(nullable FLTViewportModeBox *)viewportMode
    orientation:(nullable FLTNorthOrientationBox *)orientation
    crossSourceCollisions:(nullable NSNumber *)crossSourceCollisions
    optimizeForTerrain:(nullable NSNumber *)optimizeForTerrain
    size:(nullable FLTSize *)size
    pixelRatio:(NSNumber *)pixelRatio
    glyphsRasterizationOptions:(nullable FLTGlyphsRasterizationOptions *)glyphsRasterizationOptions {
  FLTMapOptions* pigeonResult = [[FLTMapOptions alloc] init];
  pigeonResult.contextMode = contextMode;
  pigeonResult.constrainMode = constrainMode;
  pigeonResult.viewportMode = viewportMode;
  pigeonResult.orientation = orientation;
  pigeonResult.crossSourceCollisions = crossSourceCollisions;
  pigeonResult.optimizeForTerrain = optimizeForTerrain;
  pigeonResult.size = size;
  pigeonResult.pixelRatio = pixelRatio;
  pigeonResult.glyphsRasterizationOptions = glyphsRasterizationOptions;
  return pigeonResult;
}
+ (FLTMapOptions *)fromList:(NSArray *)list {
  FLTMapOptions *pigeonResult = [[FLTMapOptions alloc] init];
  NSNumber *contextModeAsNumber = GetNullableObjectAtIndex(list, 0);
  FLTContextModeBox *contextMode = contextModeAsNumber == nil ? nil : [[FLTContextModeBox alloc] initWithValue: [contextModeAsNumber integerValue]];
  pigeonResult.contextMode = contextMode;
  NSNumber *constrainModeAsNumber = GetNullableObjectAtIndex(list, 1);
  FLTConstrainModeBox *constrainMode = constrainModeAsNumber == nil ? nil : [[FLTConstrainModeBox alloc] initWithValue: [constrainModeAsNumber integerValue]];
  pigeonResult.constrainMode = constrainMode;
  NSNumber *viewportModeAsNumber = GetNullableObjectAtIndex(list, 2);
  FLTViewportModeBox *viewportMode = viewportModeAsNumber == nil ? nil : [[FLTViewportModeBox alloc] initWithValue: [viewportModeAsNumber integerValue]];
  pigeonResult.viewportMode = viewportMode;
  NSNumber *orientationAsNumber = GetNullableObjectAtIndex(list, 3);
  FLTNorthOrientationBox *orientation = orientationAsNumber == nil ? nil : [[FLTNorthOrientationBox alloc] initWithValue: [orientationAsNumber integerValue]];
  pigeonResult.orientation = orientation;
  pigeonResult.crossSourceCollisions = GetNullableObjectAtIndex(list, 4);
  pigeonResult.optimizeForTerrain = GetNullableObjectAtIndex(list, 5);
  pigeonResult.size = [FLTSize nullableFromList:(GetNullableObjectAtIndex(list, 6))];
  pigeonResult.pixelRatio = GetNullableObjectAtIndex(list, 7);
  NSAssert(pigeonResult.pixelRatio != nil, @"");
  pigeonResult.glyphsRasterizationOptions = [FLTGlyphsRasterizationOptions nullableFromList:(GetNullableObjectAtIndex(list, 8))];
  return pigeonResult;
}
+ (nullable FLTMapOptions *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTMapOptions fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.contextMode == nil ? [NSNull null] : [NSNumber numberWithInteger:self.contextMode.value]),
    (self.constrainMode == nil ? [NSNull null] : [NSNumber numberWithInteger:self.constrainMode.value]),
    (self.viewportMode == nil ? [NSNull null] : [NSNumber numberWithInteger:self.viewportMode.value]),
    (self.orientation == nil ? [NSNull null] : [NSNumber numberWithInteger:self.orientation.value]),
    (self.crossSourceCollisions ?: [NSNull null]),
    (self.optimizeForTerrain ?: [NSNull null]),
    (self.size ? [self.size toList] : [NSNull null]),
    (self.pixelRatio ?: [NSNull null]),
    (self.glyphsRasterizationOptions ? [self.glyphsRasterizationOptions toList] : [NSNull null]),
  ];
}
@end

@implementation FLTScreenBox
+ (instancetype)makeWithMin:(FLTScreenCoordinate *)min
    max:(FLTScreenCoordinate *)max {
  FLTScreenBox* pigeonResult = [[FLTScreenBox alloc] init];
  pigeonResult.min = min;
  pigeonResult.max = max;
  return pigeonResult;
}
+ (FLTScreenBox *)fromList:(NSArray *)list {
  FLTScreenBox *pigeonResult = [[FLTScreenBox alloc] init];
  pigeonResult.min = [FLTScreenCoordinate nullableFromList:(GetNullableObjectAtIndex(list, 0))];
  NSAssert(pigeonResult.min != nil, @"");
  pigeonResult.max = [FLTScreenCoordinate nullableFromList:(GetNullableObjectAtIndex(list, 1))];
  NSAssert(pigeonResult.max != nil, @"");
  return pigeonResult;
}
+ (nullable FLTScreenBox *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTScreenBox fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.min ? [self.min toList] : [NSNull null]),
    (self.max ? [self.max toList] : [NSNull null]),
  ];
}
@end

@implementation FLTCoordinateBoundsZoom
+ (instancetype)makeWithBounds:(FLTCoordinateBounds *)bounds
    zoom:(NSNumber *)zoom {
  FLTCoordinateBoundsZoom* pigeonResult = [[FLTCoordinateBoundsZoom alloc] init];
  pigeonResult.bounds = bounds;
  pigeonResult.zoom = zoom;
  return pigeonResult;
}
+ (FLTCoordinateBoundsZoom *)fromList:(NSArray *)list {
  FLTCoordinateBoundsZoom *pigeonResult = [[FLTCoordinateBoundsZoom alloc] init];
  pigeonResult.bounds = [FLTCoordinateBounds nullableFromList:(GetNullableObjectAtIndex(list, 0))];
  NSAssert(pigeonResult.bounds != nil, @"");
  pigeonResult.zoom = GetNullableObjectAtIndex(list, 1);
  NSAssert(pigeonResult.zoom != nil, @"");
  return pigeonResult;
}
+ (nullable FLTCoordinateBoundsZoom *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTCoordinateBoundsZoom fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.bounds ? [self.bounds toList] : [NSNull null]),
    (self.zoom ?: [NSNull null]),
  ];
}
@end

@implementation FLTSize
+ (instancetype)makeWithWidth:(NSNumber *)width
    height:(NSNumber *)height {
  FLTSize* pigeonResult = [[FLTSize alloc] init];
  pigeonResult.width = width;
  pigeonResult.height = height;
  return pigeonResult;
}
+ (FLTSize *)fromList:(NSArray *)list {
  FLTSize *pigeonResult = [[FLTSize alloc] init];
  pigeonResult.width = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.width != nil, @"");
  pigeonResult.height = GetNullableObjectAtIndex(list, 1);
  NSAssert(pigeonResult.height != nil, @"");
  return pigeonResult;
}
+ (nullable FLTSize *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTSize fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.width ?: [NSNull null]),
    (self.height ?: [NSNull null]),
  ];
}
@end

@implementation FLTRenderedQueryOptions
+ (instancetype)makeWithLayerIds:(nullable NSArray<NSString *> *)layerIds
    filter:(nullable NSString *)filter {
  FLTRenderedQueryOptions* pigeonResult = [[FLTRenderedQueryOptions alloc] init];
  pigeonResult.layerIds = layerIds;
  pigeonResult.filter = filter;
  return pigeonResult;
}
+ (FLTRenderedQueryOptions *)fromList:(NSArray *)list {
  FLTRenderedQueryOptions *pigeonResult = [[FLTRenderedQueryOptions alloc] init];
  pigeonResult.layerIds = GetNullableObjectAtIndex(list, 0);
  pigeonResult.filter = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable FLTRenderedQueryOptions *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTRenderedQueryOptions fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.layerIds ?: [NSNull null]),
    (self.filter ?: [NSNull null]),
  ];
}
@end

@implementation FLTSourceQueryOptions
+ (instancetype)makeWithSourceLayerIds:(nullable NSArray<NSString *> *)sourceLayerIds
    filter:(NSString *)filter {
  FLTSourceQueryOptions* pigeonResult = [[FLTSourceQueryOptions alloc] init];
  pigeonResult.sourceLayerIds = sourceLayerIds;
  pigeonResult.filter = filter;
  return pigeonResult;
}
+ (FLTSourceQueryOptions *)fromList:(NSArray *)list {
  FLTSourceQueryOptions *pigeonResult = [[FLTSourceQueryOptions alloc] init];
  pigeonResult.sourceLayerIds = GetNullableObjectAtIndex(list, 0);
  pigeonResult.filter = GetNullableObjectAtIndex(list, 1);
  NSAssert(pigeonResult.filter != nil, @"");
  return pigeonResult;
}
+ (nullable FLTSourceQueryOptions *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTSourceQueryOptions fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.sourceLayerIds ?: [NSNull null]),
    (self.filter ?: [NSNull null]),
  ];
}
@end

@implementation FLTFeatureExtensionValue
+ (instancetype)makeWithValue:(nullable NSString *)value
    featureCollection:(nullable NSArray<NSDictionary<NSString *, id> *> *)featureCollection {
  FLTFeatureExtensionValue* pigeonResult = [[FLTFeatureExtensionValue alloc] init];
  pigeonResult.value = value;
  pigeonResult.featureCollection = featureCollection;
  return pigeonResult;
}
+ (FLTFeatureExtensionValue *)fromList:(NSArray *)list {
  FLTFeatureExtensionValue *pigeonResult = [[FLTFeatureExtensionValue alloc] init];
  pigeonResult.value = GetNullableObjectAtIndex(list, 0);
  pigeonResult.featureCollection = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable FLTFeatureExtensionValue *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTFeatureExtensionValue fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.value ?: [NSNull null]),
    (self.featureCollection ?: [NSNull null]),
  ];
}
@end

@implementation FLTQueriedFeature
+ (instancetype)makeWithFeature:(NSDictionary<NSString *, id> *)feature
    source:(NSString *)source
    sourceLayer:(nullable NSString *)sourceLayer
    state:(NSString *)state {
  FLTQueriedFeature* pigeonResult = [[FLTQueriedFeature alloc] init];
  pigeonResult.feature = feature;
  pigeonResult.source = source;
  pigeonResult.sourceLayer = sourceLayer;
  pigeonResult.state = state;
  return pigeonResult;
}
+ (FLTQueriedFeature *)fromList:(NSArray *)list {
  FLTQueriedFeature *pigeonResult = [[FLTQueriedFeature alloc] init];
  pigeonResult.feature = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.feature != nil, @"");
  pigeonResult.source = GetNullableObjectAtIndex(list, 1);
  NSAssert(pigeonResult.source != nil, @"");
  pigeonResult.sourceLayer = GetNullableObjectAtIndex(list, 2);
  pigeonResult.state = GetNullableObjectAtIndex(list, 3);
  NSAssert(pigeonResult.state != nil, @"");
  return pigeonResult;
}
+ (nullable FLTQueriedFeature *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTQueriedFeature fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.feature ?: [NSNull null]),
    (self.source ?: [NSNull null]),
    (self.sourceLayer ?: [NSNull null]),
    (self.state ?: [NSNull null]),
  ];
}
@end

@implementation FLTRenderedQueryGeometry
+ (instancetype)makeWithValue:(NSString *)value
    type:(FLTType)type {
  FLTRenderedQueryGeometry* pigeonResult = [[FLTRenderedQueryGeometry alloc] init];
  pigeonResult.value = value;
  pigeonResult.type = type;
  return pigeonResult;
}
+ (FLTRenderedQueryGeometry *)fromList:(NSArray *)list {
  FLTRenderedQueryGeometry *pigeonResult = [[FLTRenderedQueryGeometry alloc] init];
  pigeonResult.value = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.value != nil, @"");
  pigeonResult.type = [GetNullableObjectAtIndex(list, 1) integerValue];
  return pigeonResult;
}
+ (nullable FLTRenderedQueryGeometry *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTRenderedQueryGeometry fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.value ?: [NSNull null]),
    @(self.type),
  ];
}
@end

@implementation FLTOfflineRegionGeometryDefinition
+ (instancetype)makeWithStyleURL:(NSString *)styleURL
    geometry:(NSDictionary<NSString *, id> *)geometry
    minZoom:(NSNumber *)minZoom
    maxZoom:(NSNumber *)maxZoom
    pixelRatio:(NSNumber *)pixelRatio
    glyphsRasterizationMode:(FLTGlyphsRasterizationMode)glyphsRasterizationMode {
  FLTOfflineRegionGeometryDefinition* pigeonResult = [[FLTOfflineRegionGeometryDefinition alloc] init];
  pigeonResult.styleURL = styleURL;
  pigeonResult.geometry = geometry;
  pigeonResult.minZoom = minZoom;
  pigeonResult.maxZoom = maxZoom;
  pigeonResult.pixelRatio = pixelRatio;
  pigeonResult.glyphsRasterizationMode = glyphsRasterizationMode;
  return pigeonResult;
}
+ (FLTOfflineRegionGeometryDefinition *)fromList:(NSArray *)list {
  FLTOfflineRegionGeometryDefinition *pigeonResult = [[FLTOfflineRegionGeometryDefinition alloc] init];
  pigeonResult.styleURL = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.styleURL != nil, @"");
  pigeonResult.geometry = GetNullableObjectAtIndex(list, 1);
  NSAssert(pigeonResult.geometry != nil, @"");
  pigeonResult.minZoom = GetNullableObjectAtIndex(list, 2);
  NSAssert(pigeonResult.minZoom != nil, @"");
  pigeonResult.maxZoom = GetNullableObjectAtIndex(list, 3);
  NSAssert(pigeonResult.maxZoom != nil, @"");
  pigeonResult.pixelRatio = GetNullableObjectAtIndex(list, 4);
  NSAssert(pigeonResult.pixelRatio != nil, @"");
  pigeonResult.glyphsRasterizationMode = [GetNullableObjectAtIndex(list, 5) integerValue];
  return pigeonResult;
}
+ (nullable FLTOfflineRegionGeometryDefinition *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTOfflineRegionGeometryDefinition fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.styleURL ?: [NSNull null]),
    (self.geometry ?: [NSNull null]),
    (self.minZoom ?: [NSNull null]),
    (self.maxZoom ?: [NSNull null]),
    (self.pixelRatio ?: [NSNull null]),
    @(self.glyphsRasterizationMode),
  ];
}
@end

@implementation FLTOfflineRegionTilePyramidDefinition
+ (instancetype)makeWithStyleURL:(NSString *)styleURL
    bounds:(FLTCoordinateBounds *)bounds
    minZoom:(NSNumber *)minZoom
    maxZoom:(NSNumber *)maxZoom
    pixelRatio:(NSNumber *)pixelRatio
    glyphsRasterizationMode:(FLTGlyphsRasterizationMode)glyphsRasterizationMode {
  FLTOfflineRegionTilePyramidDefinition* pigeonResult = [[FLTOfflineRegionTilePyramidDefinition alloc] init];
  pigeonResult.styleURL = styleURL;
  pigeonResult.bounds = bounds;
  pigeonResult.minZoom = minZoom;
  pigeonResult.maxZoom = maxZoom;
  pigeonResult.pixelRatio = pixelRatio;
  pigeonResult.glyphsRasterizationMode = glyphsRasterizationMode;
  return pigeonResult;
}
+ (FLTOfflineRegionTilePyramidDefinition *)fromList:(NSArray *)list {
  FLTOfflineRegionTilePyramidDefinition *pigeonResult = [[FLTOfflineRegionTilePyramidDefinition alloc] init];
  pigeonResult.styleURL = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.styleURL != nil, @"");
  pigeonResult.bounds = [FLTCoordinateBounds nullableFromList:(GetNullableObjectAtIndex(list, 1))];
  NSAssert(pigeonResult.bounds != nil, @"");
  pigeonResult.minZoom = GetNullableObjectAtIndex(list, 2);
  NSAssert(pigeonResult.minZoom != nil, @"");
  pigeonResult.maxZoom = GetNullableObjectAtIndex(list, 3);
  NSAssert(pigeonResult.maxZoom != nil, @"");
  pigeonResult.pixelRatio = GetNullableObjectAtIndex(list, 4);
  NSAssert(pigeonResult.pixelRatio != nil, @"");
  pigeonResult.glyphsRasterizationMode = [GetNullableObjectAtIndex(list, 5) integerValue];
  return pigeonResult;
}
+ (nullable FLTOfflineRegionTilePyramidDefinition *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTOfflineRegionTilePyramidDefinition fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.styleURL ?: [NSNull null]),
    (self.bounds ? [self.bounds toList] : [NSNull null]),
    (self.minZoom ?: [NSNull null]),
    (self.maxZoom ?: [NSNull null]),
    (self.pixelRatio ?: [NSNull null]),
    @(self.glyphsRasterizationMode),
  ];
}
@end

@implementation FLTProjectedMeters
+ (instancetype)makeWithNorthing:(NSNumber *)northing
    easting:(NSNumber *)easting {
  FLTProjectedMeters* pigeonResult = [[FLTProjectedMeters alloc] init];
  pigeonResult.northing = northing;
  pigeonResult.easting = easting;
  return pigeonResult;
}
+ (FLTProjectedMeters *)fromList:(NSArray *)list {
  FLTProjectedMeters *pigeonResult = [[FLTProjectedMeters alloc] init];
  pigeonResult.northing = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.northing != nil, @"");
  pigeonResult.easting = GetNullableObjectAtIndex(list, 1);
  NSAssert(pigeonResult.easting != nil, @"");
  return pigeonResult;
}
+ (nullable FLTProjectedMeters *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTProjectedMeters fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.northing ?: [NSNull null]),
    (self.easting ?: [NSNull null]),
  ];
}
@end

@implementation FLTMercatorCoordinate
+ (instancetype)makeWithX:(NSNumber *)x
    y:(NSNumber *)y {
  FLTMercatorCoordinate* pigeonResult = [[FLTMercatorCoordinate alloc] init];
  pigeonResult.x = x;
  pigeonResult.y = y;
  return pigeonResult;
}
+ (FLTMercatorCoordinate *)fromList:(NSArray *)list {
  FLTMercatorCoordinate *pigeonResult = [[FLTMercatorCoordinate alloc] init];
  pigeonResult.x = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.x != nil, @"");
  pigeonResult.y = GetNullableObjectAtIndex(list, 1);
  NSAssert(pigeonResult.y != nil, @"");
  return pigeonResult;
}
+ (nullable FLTMercatorCoordinate *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTMercatorCoordinate fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.x ?: [NSNull null]),
    (self.y ?: [NSNull null]),
  ];
}
@end

@interface FLT_StyleCodecReader : FlutterStandardReader
@end
@implementation FLT_StyleCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [FLTCameraBounds fromList:[self readValue]];
    case 129: 
      return [FLTCameraBoundsOptions fromList:[self readValue]];
    case 130: 
      return [FLTCameraOptions fromList:[self readValue]];
    case 131: 
      return [FLTCameraState fromList:[self readValue]];
    case 132: 
      return [FLTCanonicalTileID fromList:[self readValue]];
    case 133: 
      return [FLTCoordinateBounds fromList:[self readValue]];
    case 134: 
      return [FLTCoordinateBoundsZoom fromList:[self readValue]];
    case 135: 
      return [FLTFeatureExtensionValue fromList:[self readValue]];
    case 136: 
      return [FLTGlyphsRasterizationOptions fromList:[self readValue]];
    case 137: 
      return [FLTImageContent fromList:[self readValue]];
    case 138: 
      return [FLTImageStretches fromList:[self readValue]];
    case 139: 
      return [FLTLayerPosition fromList:[self readValue]];
    case 140: 
      return [FLTMapAnimationOptions fromList:[self readValue]];
    case 141: 
      return [FLTMapDebugOptions fromList:[self readValue]];
    case 142: 
      return [FLTMapMemoryBudgetInMegabytes fromList:[self readValue]];
    case 143: 
      return [FLTMapMemoryBudgetInTiles fromList:[self readValue]];
    case 144: 
      return [FLTMapOptions fromList:[self readValue]];
    case 145: 
      return [FLTMbxEdgeInsets fromList:[self readValue]];
    case 146: 
      return [FLTMbxImage fromList:[self readValue]];
    case 147: 
      return [FLTMercatorCoordinate fromList:[self readValue]];
    case 148: 
      return [FLTOfflineRegionGeometryDefinition fromList:[self readValue]];
    case 149: 
      return [FLTOfflineRegionTilePyramidDefinition fromList:[self readValue]];
    case 150: 
      return [FLTProjectedMeters fromList:[self readValue]];
    case 151: 
      return [FLTQueriedFeature fromList:[self readValue]];
    case 152: 
      return [FLTRenderedQueryGeometry fromList:[self readValue]];
    case 153: 
      return [FLTRenderedQueryOptions fromList:[self readValue]];
    case 154: 
      return [FLTResourceOptions fromList:[self readValue]];
    case 155: 
      return [FLTScreenBox fromList:[self readValue]];
    case 156: 
      return [FLTScreenCoordinate fromList:[self readValue]];
    case 157: 
      return [FLTSize fromList:[self readValue]];
    case 158: 
      return [FLTSourceQueryOptions fromList:[self readValue]];
    case 159: 
      return [FLTStyleObjectInfo fromList:[self readValue]];
    case 160: 
      return [FLTStylePropertyValue fromList:[self readValue]];
    case 161: 
      return [FLTTransitionOptions fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface FLT_StyleCodecWriter : FlutterStandardWriter
@end
@implementation FLT_StyleCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[FLTCameraBounds class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraBoundsOptions class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraOptions class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraState class]]) {
    [self writeByte:131];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCanonicalTileID class]]) {
    [self writeByte:132];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCoordinateBounds class]]) {
    [self writeByte:133];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCoordinateBoundsZoom class]]) {
    [self writeByte:134];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTFeatureExtensionValue class]]) {
    [self writeByte:135];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTGlyphsRasterizationOptions class]]) {
    [self writeByte:136];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTImageContent class]]) {
    [self writeByte:137];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTImageStretches class]]) {
    [self writeByte:138];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTLayerPosition class]]) {
    [self writeByte:139];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapAnimationOptions class]]) {
    [self writeByte:140];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapDebugOptions class]]) {
    [self writeByte:141];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapMemoryBudgetInMegabytes class]]) {
    [self writeByte:142];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapMemoryBudgetInTiles class]]) {
    [self writeByte:143];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapOptions class]]) {
    [self writeByte:144];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMbxEdgeInsets class]]) {
    [self writeByte:145];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMbxImage class]]) {
    [self writeByte:146];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMercatorCoordinate class]]) {
    [self writeByte:147];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTOfflineRegionGeometryDefinition class]]) {
    [self writeByte:148];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTOfflineRegionTilePyramidDefinition class]]) {
    [self writeByte:149];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTProjectedMeters class]]) {
    [self writeByte:150];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTQueriedFeature class]]) {
    [self writeByte:151];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTRenderedQueryGeometry class]]) {
    [self writeByte:152];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTRenderedQueryOptions class]]) {
    [self writeByte:153];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTResourceOptions class]]) {
    [self writeByte:154];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTScreenBox class]]) {
    [self writeByte:155];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTScreenCoordinate class]]) {
    [self writeByte:156];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTSize class]]) {
    [self writeByte:157];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTSourceQueryOptions class]]) {
    [self writeByte:158];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTStyleObjectInfo class]]) {
    [self writeByte:159];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTStylePropertyValue class]]) {
    [self writeByte:160];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTTransitionOptions class]]) {
    [self writeByte:161];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface FLT_StyleCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FLT_StyleCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FLT_StyleCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FLT_StyleCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMethodCodec> *FLT_StyleGetCodec(void) {
  static FlutterStandardMethodCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    FLT_StyleCodecReaderWriter *readerWriter = [[FLT_StyleCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMethodCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

@implementation FLTResourceOptions
+ (instancetype)makeWithAccessToken:(NSString *)accessToken
    baseURL:(nullable NSString *)baseURL
    dataPath:(nullable NSString *)dataPath
    assetPath:(nullable NSString *)assetPath
    tileStoreUsageMode:(nullable FLTTileStoreUsageModeBox *)tileStoreUsageMode {
  FLTResourceOptions* pigeonResult = [[FLTResourceOptions alloc] init];
  pigeonResult.accessToken = accessToken;
  pigeonResult.baseURL = baseURL;
  pigeonResult.dataPath = dataPath;
  pigeonResult.assetPath = assetPath;
  pigeonResult.tileStoreUsageMode = tileStoreUsageMode;
  return pigeonResult;
}
+ (FLTResourceOptions *)fromList:(NSArray *)list {
  FLTResourceOptions *pigeonResult = [[FLTResourceOptions alloc] init];
  pigeonResult.accessToken = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.accessToken != nil, @"");
  pigeonResult.baseURL = GetNullableObjectAtIndex(list, 1);
  pigeonResult.dataPath = GetNullableObjectAtIndex(list, 2);
  pigeonResult.assetPath = GetNullableObjectAtIndex(list, 3);
  NSNumber *tileStoreUsageModeAsNumber = GetNullableObjectAtIndex(list, 4);
  FLTTileStoreUsageModeBox *tileStoreUsageMode = tileStoreUsageModeAsNumber == nil ? nil : [[FLTTileStoreUsageModeBox alloc] initWithValue: [tileStoreUsageModeAsNumber integerValue]];
  pigeonResult.tileStoreUsageMode = tileStoreUsageMode;
  return pigeonResult;
}
+ (nullable FLTResourceOptions *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTResourceOptions fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.accessToken ?: [NSNull null]),
    (self.baseURL ?: [NSNull null]),
    (self.dataPath ?: [NSNull null]),
    (self.assetPath ?: [NSNull null]),
    (self.tileStoreUsageMode == nil ? [NSNull null] : [NSNumber numberWithInteger:self.tileStoreUsageMode.value]),
  ];
}
@end

@implementation FLTStyleObjectInfo
+ (instancetype)makeWithId:(NSString *)id
    type:(NSString *)type {
  FLTStyleObjectInfo* pigeonResult = [[FLTStyleObjectInfo alloc] init];
  pigeonResult.id = id;
  pigeonResult.type = type;
  return pigeonResult;
}
+ (FLTStyleObjectInfo *)fromList:(NSArray *)list {
  FLTStyleObjectInfo *pigeonResult = [[FLTStyleObjectInfo alloc] init];
  pigeonResult.id = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.id != nil, @"");
  pigeonResult.type = GetNullableObjectAtIndex(list, 1);
  NSAssert(pigeonResult.type != nil, @"");
  return pigeonResult;
}
+ (nullable FLTStyleObjectInfo *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTStyleObjectInfo fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.id ?: [NSNull null]),
    (self.type ?: [NSNull null]),
  ];
}
@end

@implementation FLTMbxImage
+ (instancetype)makeWithWidth:(NSNumber *)width
    height:(NSNumber *)height
    data:(FlutterStandardTypedData *)data {
  FLTMbxImage* pigeonResult = [[FLTMbxImage alloc] init];
  pigeonResult.width = width;
  pigeonResult.height = height;
  pigeonResult.data = data;
  return pigeonResult;
}
+ (FLTMbxImage *)fromList:(NSArray *)list {
  FLTMbxImage *pigeonResult = [[FLTMbxImage alloc] init];
  pigeonResult.width = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.width != nil, @"");
  pigeonResult.height = GetNullableObjectAtIndex(list, 1);
  NSAssert(pigeonResult.height != nil, @"");
  pigeonResult.data = GetNullableObjectAtIndex(list, 2);
  NSAssert(pigeonResult.data != nil, @"");
  return pigeonResult;
}
+ (nullable FLTMbxImage *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTMbxImage fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.width ?: [NSNull null]),
    (self.height ?: [NSNull null]),
    (self.data ?: [NSNull null]),
  ];
}
@end

@implementation FLTImageStretches
+ (instancetype)makeWithFirst:(NSNumber *)first
    second:(NSNumber *)second {
  FLTImageStretches* pigeonResult = [[FLTImageStretches alloc] init];
  pigeonResult.first = first;
  pigeonResult.second = second;
  return pigeonResult;
}
+ (FLTImageStretches *)fromList:(NSArray *)list {
  FLTImageStretches *pigeonResult = [[FLTImageStretches alloc] init];
  pigeonResult.first = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.first != nil, @"");
  pigeonResult.second = GetNullableObjectAtIndex(list, 1);
  NSAssert(pigeonResult.second != nil, @"");
  return pigeonResult;
}
+ (nullable FLTImageStretches *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTImageStretches fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.first ?: [NSNull null]),
    (self.second ?: [NSNull null]),
  ];
}
@end

@implementation FLTImageContent
+ (instancetype)makeWithLeft:(NSNumber *)left
    top:(NSNumber *)top
    right:(NSNumber *)right
    bottom:(NSNumber *)bottom {
  FLTImageContent* pigeonResult = [[FLTImageContent alloc] init];
  pigeonResult.left = left;
  pigeonResult.top = top;
  pigeonResult.right = right;
  pigeonResult.bottom = bottom;
  return pigeonResult;
}
+ (FLTImageContent *)fromList:(NSArray *)list {
  FLTImageContent *pigeonResult = [[FLTImageContent alloc] init];
  pigeonResult.left = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.left != nil, @"");
  pigeonResult.top = GetNullableObjectAtIndex(list, 1);
  NSAssert(pigeonResult.top != nil, @"");
  pigeonResult.right = GetNullableObjectAtIndex(list, 2);
  NSAssert(pigeonResult.right != nil, @"");
  pigeonResult.bottom = GetNullableObjectAtIndex(list, 3);
  NSAssert(pigeonResult.bottom != nil, @"");
  return pigeonResult;
}
+ (nullable FLTImageContent *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTImageContent fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.left ?: [NSNull null]),
    (self.top ?: [NSNull null]),
    (self.right ?: [NSNull null]),
    (self.bottom ?: [NSNull null]),
  ];
}
@end

@implementation FLTCanonicalTileID
+ (instancetype)makeWithZ:(NSNumber *)z
    x:(NSNumber *)x
    y:(NSNumber *)y {
  FLTCanonicalTileID* pigeonResult = [[FLTCanonicalTileID alloc] init];
  pigeonResult.z = z;
  pigeonResult.x = x;
  pigeonResult.y = y;
  return pigeonResult;
}
+ (FLTCanonicalTileID *)fromList:(NSArray *)list {
  FLTCanonicalTileID *pigeonResult = [[FLTCanonicalTileID alloc] init];
  pigeonResult.z = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.z != nil, @"");
  pigeonResult.x = GetNullableObjectAtIndex(list, 1);
  NSAssert(pigeonResult.x != nil, @"");
  pigeonResult.y = GetNullableObjectAtIndex(list, 2);
  NSAssert(pigeonResult.y != nil, @"");
  return pigeonResult;
}
+ (nullable FLTCanonicalTileID *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTCanonicalTileID fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.z ?: [NSNull null]),
    (self.x ?: [NSNull null]),
    (self.y ?: [NSNull null]),
  ];
}
@end

@implementation FLTStylePropertyValue
+ (instancetype)makeWithValue:(NSString *)value
    kind:(FLTStylePropertyValueKind)kind {
  FLTStylePropertyValue* pigeonResult = [[FLTStylePropertyValue alloc] init];
  pigeonResult.value = value;
  pigeonResult.kind = kind;
  return pigeonResult;
}
+ (FLTStylePropertyValue *)fromList:(NSArray *)list {
  FLTStylePropertyValue *pigeonResult = [[FLTStylePropertyValue alloc] init];
  pigeonResult.value = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.value != nil, @"");
  pigeonResult.kind = [GetNullableObjectAtIndex(list, 1) integerValue];
  return pigeonResult;
}
+ (nullable FLTStylePropertyValue *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTStylePropertyValue fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.value ?: [NSNull null]),
    @(self.kind),
  ];
}
@end

@interface FLT_AnimationManagerCodecReader : FlutterStandardReader
@end
@implementation FLT_AnimationManagerCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [FLTCameraOptions fromList:[self readValue]];
    case 129: 
      return [FLTMapAnimationOptions fromList:[self readValue]];
    case 130: 
      return [FLTMbxEdgeInsets fromList:[self readValue]];
    case 131: 
      return [FLTScreenCoordinate fromList:[self readValue]];
    case 132: 
      return [FLTCameraState fromList:[self readValue]];
    case 133: 
      return [FLTCoordinateBounds fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface FLT_AnimationManagerCodecWriter : FlutterStandardWriter
@end
@implementation FLT_AnimationManagerCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[FLTCameraOptions class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapAnimationOptions class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMbxEdgeInsets class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTScreenCoordinate class]]) {
    [self writeByte:131];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraState class]]) {
    [self writeByte:132];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCoordinateBounds class]]) {
    [self writeByte:133];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface FLT_AnimationManagerCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FLT_AnimationManagerCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FLT_AnimationManagerCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FLT_AnimationManagerCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMethodCodec> *FLT_AnimationManagerGetCodec(void) {
  static FlutterStandardMethodCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    FLT_AnimationManagerCodecReaderWriter *readerWriter = [[FLT_AnimationManagerCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMethodCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void FLT_AnimationManagerSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLT_AnimationManager> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.easeTo"
        binaryMessenger:binaryMessenger
        codec:FLT_AnimationManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(easeToCameraOptions:mapAnimationOptions:error:)], @"FLT_AnimationManager api (%@) doesn't respond to @selector(easeToCameraOptions:mapAnimationOptions:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTCameraOptions *arg_cameraOptions = GetNullableObjectAtIndex(args, 0);
        FLTMapAnimationOptions *arg_mapAnimationOptions = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api easeToCameraOptions:arg_cameraOptions mapAnimationOptions:arg_mapAnimationOptions error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.flyTo"
        binaryMessenger:binaryMessenger
        codec:FLT_AnimationManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(flyToCameraOptions:mapAnimationOptions:error:)], @"FLT_AnimationManager api (%@) doesn't respond to @selector(flyToCameraOptions:mapAnimationOptions:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTCameraOptions *arg_cameraOptions = GetNullableObjectAtIndex(args, 0);
        FLTMapAnimationOptions *arg_mapAnimationOptions = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api flyToCameraOptions:arg_cameraOptions mapAnimationOptions:arg_mapAnimationOptions error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.pitchBy"
        binaryMessenger:binaryMessenger
        codec:FLT_AnimationManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(pitchByPitch:mapAnimationOptions:error:)], @"FLT_AnimationManager api (%@) doesn't respond to @selector(pitchByPitch:mapAnimationOptions:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSNumber *arg_pitch = GetNullableObjectAtIndex(args, 0);
        FLTMapAnimationOptions *arg_mapAnimationOptions = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api pitchByPitch:arg_pitch mapAnimationOptions:arg_mapAnimationOptions error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.scaleBy"
        binaryMessenger:binaryMessenger
        codec:FLT_AnimationManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(scaleByAmount:screenCoordinate:mapAnimationOptions:error:)], @"FLT_AnimationManager api (%@) doesn't respond to @selector(scaleByAmount:screenCoordinate:mapAnimationOptions:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSNumber *arg_amount = GetNullableObjectAtIndex(args, 0);
        FLTScreenCoordinate *arg_screenCoordinate = GetNullableObjectAtIndex(args, 1);
        FLTMapAnimationOptions *arg_mapAnimationOptions = GetNullableObjectAtIndex(args, 2);
        FlutterError *error;
        [api scaleByAmount:arg_amount screenCoordinate:arg_screenCoordinate mapAnimationOptions:arg_mapAnimationOptions error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.moveBy"
        binaryMessenger:binaryMessenger
        codec:FLT_AnimationManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(moveByScreenCoordinate:mapAnimationOptions:error:)], @"FLT_AnimationManager api (%@) doesn't respond to @selector(moveByScreenCoordinate:mapAnimationOptions:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTScreenCoordinate *arg_screenCoordinate = GetNullableObjectAtIndex(args, 0);
        FLTMapAnimationOptions *arg_mapAnimationOptions = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api moveByScreenCoordinate:arg_screenCoordinate mapAnimationOptions:arg_mapAnimationOptions error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.rotateBy"
        binaryMessenger:binaryMessenger
        codec:FLT_AnimationManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(rotateByFirst:second:mapAnimationOptions:error:)], @"FLT_AnimationManager api (%@) doesn't respond to @selector(rotateByFirst:second:mapAnimationOptions:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTScreenCoordinate *arg_first = GetNullableObjectAtIndex(args, 0);
        FLTScreenCoordinate *arg_second = GetNullableObjectAtIndex(args, 1);
        FLTMapAnimationOptions *arg_mapAnimationOptions = GetNullableObjectAtIndex(args, 2);
        FlutterError *error;
        [api rotateByFirst:arg_first second:arg_second mapAnimationOptions:arg_mapAnimationOptions error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.cancelCameraAnimation"
        binaryMessenger:binaryMessenger
        codec:FLT_AnimationManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(cancelCameraAnimationWithError:)], @"FLT_AnimationManager api (%@) doesn't respond to @selector(cancelCameraAnimationWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api cancelCameraAnimationWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FLT_CameraManagerCodecReader : FlutterStandardReader
@end
@implementation FLT_CameraManagerCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [FLTCameraBounds fromList:[self readValue]];
    case 129: 
      return [FLTCameraBoundsOptions fromList:[self readValue]];
    case 130: 
      return [FLTCameraOptions fromList:[self readValue]];
    case 131: 
      return [FLTCameraState fromList:[self readValue]];
    case 132: 
      return [FLTCanonicalTileID fromList:[self readValue]];
    case 133: 
      return [FLTCoordinateBounds fromList:[self readValue]];
    case 134: 
      return [FLTCoordinateBoundsZoom fromList:[self readValue]];
    case 135: 
      return [FLTFeatureExtensionValue fromList:[self readValue]];
    case 136: 
      return [FLTGlyphsRasterizationOptions fromList:[self readValue]];
    case 137: 
      return [FLTImageContent fromList:[self readValue]];
    case 138: 
      return [FLTImageStretches fromList:[self readValue]];
    case 139: 
      return [FLTLayerPosition fromList:[self readValue]];
    case 140: 
      return [FLTMapAnimationOptions fromList:[self readValue]];
    case 141: 
      return [FLTMapDebugOptions fromList:[self readValue]];
    case 142: 
      return [FLTMapMemoryBudgetInMegabytes fromList:[self readValue]];
    case 143: 
      return [FLTMapMemoryBudgetInTiles fromList:[self readValue]];
    case 144: 
      return [FLTMapOptions fromList:[self readValue]];
    case 145: 
      return [FLTMbxEdgeInsets fromList:[self readValue]];
    case 146: 
      return [FLTMbxImage fromList:[self readValue]];
    case 147: 
      return [FLTMercatorCoordinate fromList:[self readValue]];
    case 148: 
      return [FLTOfflineRegionGeometryDefinition fromList:[self readValue]];
    case 149: 
      return [FLTOfflineRegionTilePyramidDefinition fromList:[self readValue]];
    case 150: 
      return [FLTProjectedMeters fromList:[self readValue]];
    case 151: 
      return [FLTQueriedFeature fromList:[self readValue]];
    case 152: 
      return [FLTRenderedQueryGeometry fromList:[self readValue]];
    case 153: 
      return [FLTRenderedQueryOptions fromList:[self readValue]];
    case 154: 
      return [FLTResourceOptions fromList:[self readValue]];
    case 155: 
      return [FLTScreenBox fromList:[self readValue]];
    case 156: 
      return [FLTScreenCoordinate fromList:[self readValue]];
    case 157: 
      return [FLTSize fromList:[self readValue]];
    case 158: 
      return [FLTSourceQueryOptions fromList:[self readValue]];
    case 159: 
      return [FLTStyleObjectInfo fromList:[self readValue]];
    case 160: 
      return [FLTStylePropertyValue fromList:[self readValue]];
    case 161: 
      return [FLTTransitionOptions fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface FLT_CameraManagerCodecWriter : FlutterStandardWriter
@end
@implementation FLT_CameraManagerCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[FLTCameraBounds class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraBoundsOptions class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraOptions class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraState class]]) {
    [self writeByte:131];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCanonicalTileID class]]) {
    [self writeByte:132];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCoordinateBounds class]]) {
    [self writeByte:133];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCoordinateBoundsZoom class]]) {
    [self writeByte:134];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTFeatureExtensionValue class]]) {
    [self writeByte:135];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTGlyphsRasterizationOptions class]]) {
    [self writeByte:136];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTImageContent class]]) {
    [self writeByte:137];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTImageStretches class]]) {
    [self writeByte:138];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTLayerPosition class]]) {
    [self writeByte:139];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapAnimationOptions class]]) {
    [self writeByte:140];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapDebugOptions class]]) {
    [self writeByte:141];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapMemoryBudgetInMegabytes class]]) {
    [self writeByte:142];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapMemoryBudgetInTiles class]]) {
    [self writeByte:143];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapOptions class]]) {
    [self writeByte:144];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMbxEdgeInsets class]]) {
    [self writeByte:145];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMbxImage class]]) {
    [self writeByte:146];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMercatorCoordinate class]]) {
    [self writeByte:147];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTOfflineRegionGeometryDefinition class]]) {
    [self writeByte:148];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTOfflineRegionTilePyramidDefinition class]]) {
    [self writeByte:149];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTProjectedMeters class]]) {
    [self writeByte:150];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTQueriedFeature class]]) {
    [self writeByte:151];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTRenderedQueryGeometry class]]) {
    [self writeByte:152];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTRenderedQueryOptions class]]) {
    [self writeByte:153];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTResourceOptions class]]) {
    [self writeByte:154];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTScreenBox class]]) {
    [self writeByte:155];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTScreenCoordinate class]]) {
    [self writeByte:156];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTSize class]]) {
    [self writeByte:157];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTSourceQueryOptions class]]) {
    [self writeByte:158];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTStyleObjectInfo class]]) {
    [self writeByte:159];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTStylePropertyValue class]]) {
    [self writeByte:160];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTTransitionOptions class]]) {
    [self writeByte:161];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface FLT_CameraManagerCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FLT_CameraManagerCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FLT_CameraManagerCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FLT_CameraManagerCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FLT_CameraManagerGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    FLT_CameraManagerCodecReaderWriter *readerWriter = [[FLT_CameraManagerCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void FLT_CameraManagerSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLT_CameraManager> *api) {
  /// Convenience method that returns the `camera options` object for given parameters.
  ///
  /// @param bounds The `coordinate bounds` of the camera.
  /// @param padding The `edge insets` of the camera.
  /// @param bearing The bearing of the camera.
  /// @param pitch The pitch of the camera.
  ///
  /// @return The `camera options` object representing the provided parameters.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForCoordinateBounds"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(cameraForCoordinateBoundsBounds:padding:bearing:pitch:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(cameraForCoordinateBoundsBounds:padding:bearing:pitch:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTCoordinateBounds *arg_bounds = GetNullableObjectAtIndex(args, 0);
        FLTMbxEdgeInsets *arg_padding = GetNullableObjectAtIndex(args, 1);
        NSNumber *arg_bearing = GetNullableObjectAtIndex(args, 2);
        NSNumber *arg_pitch = GetNullableObjectAtIndex(args, 3);
        FlutterError *error;
        FLTCameraOptions *output = [api cameraForCoordinateBoundsBounds:arg_bounds padding:arg_padding bearing:arg_bearing pitch:arg_pitch error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Convenience method that returns the `camera options` object for given parameters.
  ///
  /// @param coordinates The `coordinates` representing the bounds of the camera.
  /// @param padding The `edge insets` of the camera.
  /// @param bearing The bearing of the camera.
  /// @param pitch The pitch of the camera.
  ///
  /// @return The `camera options` object representing the provided parameters.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForCoordinates"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(cameraForCoordinatesCoordinates:padding:bearing:pitch:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(cameraForCoordinatesCoordinates:padding:bearing:pitch:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSArray<NSDictionary<NSString *, id> *> *arg_coordinates = GetNullableObjectAtIndex(args, 0);
        FLTMbxEdgeInsets *arg_padding = GetNullableObjectAtIndex(args, 1);
        NSNumber *arg_bearing = GetNullableObjectAtIndex(args, 2);
        NSNumber *arg_pitch = GetNullableObjectAtIndex(args, 3);
        FlutterError *error;
        FLTCameraOptions *output = [api cameraForCoordinatesCoordinates:arg_coordinates padding:arg_padding bearing:arg_bearing pitch:arg_pitch error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Convenience method that adjusts the provided `camera options` object for given parameters.
  ///
  /// Returns the provided `camera` options with zoom adjusted to fit `coordinates` into the `box`, so that `coordinates` on the left,
  /// top and right of the effective `camera` center at the principal point of the projection (defined by `padding`) fit into the `box`.
  /// Returns the provided `camera` options object unchanged upon an error.
  /// Note that this method may fail if the principal point of the projection is not inside the `box` or
  /// if there is no sufficient screen space, defined by principal point and the `box`, to fit the geometry.
  ///
  /// @param coordinates The `coordinates` representing the bounds of the camera.
  /// @param camera The `camera options` for which zoom should be adjusted. Note that the `camera.center` is required.
  /// @param box The `screen box` into which `coordinates` should fit.
  ///
  /// @return The `camera options` object with the zoom level adjusted to fit `coordinates` into the `box`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForCoordinatesCameraOptions"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(cameraForCoordinatesCameraOptionsCoordinates:camera:box:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(cameraForCoordinatesCameraOptionsCoordinates:camera:box:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSArray<NSDictionary<NSString *, id> *> *arg_coordinates = GetNullableObjectAtIndex(args, 0);
        FLTCameraOptions *arg_camera = GetNullableObjectAtIndex(args, 1);
        FLTScreenBox *arg_box = GetNullableObjectAtIndex(args, 2);
        FlutterError *error;
        FLTCameraOptions *output = [api cameraForCoordinatesCameraOptionsCoordinates:arg_coordinates camera:arg_camera box:arg_box error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Convenience method that returns the `camera options` object for given parameters.
  ///
  /// @param geometry The `geometry` representing the bounds of the camera.
  /// @param padding The `edge insets` of the camera.
  /// @param bearing The bearing of the camera.
  /// @param pitch The pitch of the camera.
  ///
  /// @return The `camera options` object representing the provided parameters.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForGeometry"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(cameraForGeometryGeometry:padding:bearing:pitch:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(cameraForGeometryGeometry:padding:bearing:pitch:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSDictionary<NSString *, id> *arg_geometry = GetNullableObjectAtIndex(args, 0);
        FLTMbxEdgeInsets *arg_padding = GetNullableObjectAtIndex(args, 1);
        NSNumber *arg_bearing = GetNullableObjectAtIndex(args, 2);
        NSNumber *arg_pitch = GetNullableObjectAtIndex(args, 3);
        FlutterError *error;
        FLTCameraOptions *output = [api cameraForGeometryGeometry:arg_geometry padding:arg_padding bearing:arg_bearing pitch:arg_pitch error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the `coordinate bounds` for a given camera.
  ///
  /// Note that if the given `camera` shows the antimeridian, the returned wrapped `coordinate bounds`
  /// might not represent the minimum bounding box.
  ///
  /// @param camera The `camera options` to use for calculating `coordinate bounds`.
  ///
  /// @return The `coordinate bounds` object representing a given `camera`.
  ///
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateBoundsForCamera"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(coordinateBoundsForCameraCamera:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(coordinateBoundsForCameraCamera:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTCameraOptions *arg_camera = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        FLTCoordinateBounds *output = [api coordinateBoundsForCameraCamera:arg_camera error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the `coordinate bounds` for a given camera.
  ///
  /// This method is useful if the `camera` shows the antimeridian.
  ///
  /// @param camera The `camera options` to use for calculating `coordinate bounds`.
  ///
  /// @return The `coordinate bounds` object representing a given `camera`.
  ///
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateBoundsForCameraUnwrapped"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(coordinateBoundsForCameraUnwrappedCamera:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(coordinateBoundsForCameraUnwrappedCamera:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTCameraOptions *arg_camera = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        FLTCoordinateBounds *output = [api coordinateBoundsForCameraUnwrappedCamera:arg_camera error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the `coordinate bounds` and the `zoom` for a given `camera`.
  ///
  /// Note that if the given `camera` shows the antimeridian, the returned wrapped `coordinate bounds`
  /// might not represent the minimum bounding box.
  ///
  /// @param camera The `camera options` to use for calculating `coordinate bounds` and `zoom`.
  ///
  /// @return The object representing `coordinate bounds` and `zoom` for a given `camera`.
  ///
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateBoundsZoomForCamera"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(coordinateBoundsZoomForCameraCamera:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(coordinateBoundsZoomForCameraCamera:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTCameraOptions *arg_camera = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        FLTCoordinateBoundsZoom *output = [api coordinateBoundsZoomForCameraCamera:arg_camera error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the unwrapped `coordinate bounds` and `zoom` for a given `camera`.
  ///
  /// This method is useful if the `camera` shows the antimeridian.
  ///
  /// @param camera The `camera options` to use for calculating `coordinate bounds` and `zoom`.
  ///
  /// @return The object representing `coordinate bounds` and `zoom` for a given `camera`.
  ///
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateBoundsZoomForCameraUnwrapped"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(coordinateBoundsZoomForCameraUnwrappedCamera:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(coordinateBoundsZoomForCameraUnwrappedCamera:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTCameraOptions *arg_camera = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        FLTCoordinateBoundsZoom *output = [api coordinateBoundsZoomForCameraUnwrappedCamera:arg_camera error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Calculates a `screen coordinate` that corresponds to a geographical coordinate
  /// (i.e., longitude-latitude pair).
  ///
  /// The `screen coordinate` is in `logical pixels` relative to the top left corner
  /// of the map (not of the whole screen).
  ///
  /// @param coordinate A geographical `coordinate` on the map to convert to a `screen coordinate`.
  ///
  /// @return A `screen coordinate` on the screen in `logical pixels`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.pixelForCoordinate"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(pixelForCoordinateCoordinate:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(pixelForCoordinateCoordinate:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSDictionary<NSString *, id> *arg_coordinate = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        FLTScreenCoordinate *output = [api pixelForCoordinateCoordinate:arg_coordinate error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Calculates a geographical `coordinate` (i.e., longitude-latitude pair) that corresponds
  /// to a `screen coordinate`.
  ///
  /// The screen coordinate is in `logical pixels`relative to the top left corner
  /// of the map (not of the whole screen).
  ///
  /// @param pixel A `screen coordinate` on the screen in `logical pixels`.
  ///
  /// @return A geographical `coordinate` corresponding to a given `screen coordinate`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateForPixel"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(coordinateForPixelPixel:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(coordinateForPixelPixel:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTScreenCoordinate *arg_pixel = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSDictionary<NSString *, id> *output = [api coordinateForPixelPixel:arg_pixel error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Calculates `screen coordinates` that correspond to geographical `coordinates`
  /// (i.e., longitude-latitude pairs).
  ///
  /// The `screen coordinates` are in `logical pixels` relative to the top left corner
  /// of the map (not of the whole screen).
  ///
  /// @param coordinates A geographical `coordinates` on the map to convert to `screen coordinates`.
  ///
  /// @return A `screen coordinates` in `logical pixels` for a given geographical `coordinates`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.pixelsForCoordinates"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(pixelsForCoordinatesCoordinates:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(pixelsForCoordinatesCoordinates:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSArray<NSDictionary<NSString *, id> *> *arg_coordinates = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSArray<FLTScreenCoordinate *> *output = [api pixelsForCoordinatesCoordinates:arg_coordinates error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Calculates geographical `coordinates` (i.e., longitude-latitude pairs) that correspond
  /// to `screen coordinates`.
  ///
  /// The screen coordinates are in `logical pixels` relative to the top left corner
  /// of the map (not of the whole screen).
  ///
  /// @param pixels A `screen coordinates` in `logical pixels`.
  ///
  /// @return A `geographical coordinates` that correspond to a given `screen coordinates`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinatesForPixels"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(coordinatesForPixelsPixels:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(coordinatesForPixelsPixels:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSArray<FLTScreenCoordinate *> *arg_pixels = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSArray<NSDictionary<NSString *, id> *> *output = [api coordinatesForPixelsPixels:arg_pixels error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Changes the map view by any combination of center, zoom, bearing, and pitch, without an animated transition.
  /// The map will retain its current values for any details not passed via the camera options argument.
  /// It is not guaranteed that the provided `camera options` will be set, the map may apply constraints resulting in a
  /// different `camera state`.
  ///
  /// @param cameraOptions The new `camera options` to be set.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.setCamera"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setCameraCameraOptions:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(setCameraCameraOptions:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTCameraOptions *arg_cameraOptions = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api setCameraCameraOptions:arg_cameraOptions error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the current `camera state`.
  ///
  /// @return The current `camera state`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.getCameraState"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getCameraStateWithError:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(getCameraStateWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FLTCameraState *output = [api getCameraStateWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets the `camera bounds options` of the map. The map will retain its current values for any
  /// details not passed via the camera bounds options arguments.
  /// When camera bounds options are set, the camera center is constrained by these bounds, as well as the minimum
  /// zoom level of the camera, to prevent out of bounds areas to be visible.
  /// Note that tilting or rotating the map, or setting stricter minimum and maximum zoom within `options` may still cause some out of bounds areas to become visible.
  ///
  /// @param options The `camera bounds options` to set.
  /// @return A string describing an error if the operation was not successful, expected with `void` value otherwise.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.setBounds"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setBoundsOptions:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(setBoundsOptions:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTCameraBoundsOptions *arg_options = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api setBoundsOptions:arg_options error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the `camera bounds` of the map.
  /// @return A `camera bounds` of the map.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.getBounds"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getBoundsWithError:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(getBoundsWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FLTCameraBounds *output = [api getBoundsWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Prepares the drag gesture to use the provided screen coordinate as a pivot `point`. This function should be called each time when user starts a dragging action (e.g. by clicking on the map). The following dragging will be relative to the pivot.
  ///
  /// @param point The pivot `screen coordinate`, measured in `logical pixels` from top to bottom and from left to right.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.dragStart"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(dragStartPoint:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(dragStartPoint:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTScreenCoordinate *arg_point = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api dragStartPoint:arg_point error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Calculates target point where camera should move after drag. The method should be called after `dragStart` and before `dragEnd`.
  ///
  /// @param fromPoint The `screen coordinate` to drag the map from, measured in `logical pixels` from top to bottom and from left to right.
  /// @param toPoint The `screen coordinate` to drag the map to, measured in `logical pixels` from top to bottom and from left to right.
  ///
  /// @return The `camera options` object showing the end point.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.getDragCameraOptions"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getDragCameraOptionsFromPoint:toPoint:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(getDragCameraOptionsFromPoint:toPoint:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTScreenCoordinate *arg_fromPoint = GetNullableObjectAtIndex(args, 0);
        FLTScreenCoordinate *arg_toPoint = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        FLTCameraOptions *output = [api getDragCameraOptionsFromPoint:arg_fromPoint toPoint:arg_toPoint error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Ends the ongoing drag gesture. This function should be called always after the user has ended a drag gesture initiated by `dragStart`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.dragEnd"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(dragEndWithError:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(dragEndWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api dragEndWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FLT_MapInterfaceCodecReader : FlutterStandardReader
@end
@implementation FLT_MapInterfaceCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [FLTCameraBounds fromList:[self readValue]];
    case 129: 
      return [FLTCameraBoundsOptions fromList:[self readValue]];
    case 130: 
      return [FLTCameraOptions fromList:[self readValue]];
    case 131: 
      return [FLTCameraState fromList:[self readValue]];
    case 132: 
      return [FLTCanonicalTileID fromList:[self readValue]];
    case 133: 
      return [FLTCoordinateBounds fromList:[self readValue]];
    case 134: 
      return [FLTCoordinateBoundsZoom fromList:[self readValue]];
    case 135: 
      return [FLTFeatureExtensionValue fromList:[self readValue]];
    case 136: 
      return [FLTGlyphsRasterizationOptions fromList:[self readValue]];
    case 137: 
      return [FLTImageContent fromList:[self readValue]];
    case 138: 
      return [FLTImageStretches fromList:[self readValue]];
    case 139: 
      return [FLTLayerPosition fromList:[self readValue]];
    case 140: 
      return [FLTMapAnimationOptions fromList:[self readValue]];
    case 141: 
      return [FLTMapDebugOptions fromList:[self readValue]];
    case 142: 
      return [FLTMapMemoryBudgetInMegabytes fromList:[self readValue]];
    case 143: 
      return [FLTMapMemoryBudgetInTiles fromList:[self readValue]];
    case 144: 
      return [FLTMapOptions fromList:[self readValue]];
    case 145: 
      return [FLTMbxEdgeInsets fromList:[self readValue]];
    case 146: 
      return [FLTMbxImage fromList:[self readValue]];
    case 147: 
      return [FLTMercatorCoordinate fromList:[self readValue]];
    case 148: 
      return [FLTOfflineRegionGeometryDefinition fromList:[self readValue]];
    case 149: 
      return [FLTOfflineRegionTilePyramidDefinition fromList:[self readValue]];
    case 150: 
      return [FLTProjectedMeters fromList:[self readValue]];
    case 151: 
      return [FLTQueriedFeature fromList:[self readValue]];
    case 152: 
      return [FLTRenderedQueryGeometry fromList:[self readValue]];
    case 153: 
      return [FLTRenderedQueryOptions fromList:[self readValue]];
    case 154: 
      return [FLTResourceOptions fromList:[self readValue]];
    case 155: 
      return [FLTScreenBox fromList:[self readValue]];
    case 156: 
      return [FLTScreenCoordinate fromList:[self readValue]];
    case 157: 
      return [FLTSize fromList:[self readValue]];
    case 158: 
      return [FLTSourceQueryOptions fromList:[self readValue]];
    case 159: 
      return [FLTStyleObjectInfo fromList:[self readValue]];
    case 160: 
      return [FLTStylePropertyValue fromList:[self readValue]];
    case 161: 
      return [FLTTransitionOptions fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface FLT_MapInterfaceCodecWriter : FlutterStandardWriter
@end
@implementation FLT_MapInterfaceCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[FLTCameraBounds class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraBoundsOptions class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraOptions class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraState class]]) {
    [self writeByte:131];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCanonicalTileID class]]) {
    [self writeByte:132];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCoordinateBounds class]]) {
    [self writeByte:133];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCoordinateBoundsZoom class]]) {
    [self writeByte:134];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTFeatureExtensionValue class]]) {
    [self writeByte:135];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTGlyphsRasterizationOptions class]]) {
    [self writeByte:136];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTImageContent class]]) {
    [self writeByte:137];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTImageStretches class]]) {
    [self writeByte:138];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTLayerPosition class]]) {
    [self writeByte:139];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapAnimationOptions class]]) {
    [self writeByte:140];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapDebugOptions class]]) {
    [self writeByte:141];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapMemoryBudgetInMegabytes class]]) {
    [self writeByte:142];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapMemoryBudgetInTiles class]]) {
    [self writeByte:143];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapOptions class]]) {
    [self writeByte:144];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMbxEdgeInsets class]]) {
    [self writeByte:145];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMbxImage class]]) {
    [self writeByte:146];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMercatorCoordinate class]]) {
    [self writeByte:147];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTOfflineRegionGeometryDefinition class]]) {
    [self writeByte:148];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTOfflineRegionTilePyramidDefinition class]]) {
    [self writeByte:149];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTProjectedMeters class]]) {
    [self writeByte:150];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTQueriedFeature class]]) {
    [self writeByte:151];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTRenderedQueryGeometry class]]) {
    [self writeByte:152];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTRenderedQueryOptions class]]) {
    [self writeByte:153];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTResourceOptions class]]) {
    [self writeByte:154];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTScreenBox class]]) {
    [self writeByte:155];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTScreenCoordinate class]]) {
    [self writeByte:156];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTSize class]]) {
    [self writeByte:157];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTSourceQueryOptions class]]) {
    [self writeByte:158];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTStyleObjectInfo class]]) {
    [self writeByte:159];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTStylePropertyValue class]]) {
    [self writeByte:160];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTTransitionOptions class]]) {
    [self writeByte:161];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface FLT_MapInterfaceCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FLT_MapInterfaceCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FLT_MapInterfaceCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FLT_MapInterfaceCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMethodCodec> *FLT_MapInterfaceGetCodec(void) {
  static FlutterStandardMethodCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    FLT_MapInterfaceCodecReaderWriter *readerWriter = [[FLT_MapInterfaceCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMethodCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void FLT_MapInterfaceSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLT_MapInterface> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.loadStyleURI"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(loadStyleURIStyleURI:completion:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(loadStyleURIStyleURI:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_styleURI = GetNullableObjectAtIndex(args, 0);
        [api loadStyleURIStyleURI:arg_styleURI completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.loadStyleJson"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(loadStyleJsonStyleJson:completion:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(loadStyleJsonStyleJson:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_styleJson = GetNullableObjectAtIndex(args, 0);
        [api loadStyleJsonStyleJson:arg_styleJson completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.clearData"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(clearDataWithCompletion:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(clearDataWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api clearDataWithCompletion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setMemoryBudget"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setMemoryBudgetMapMemoryBudgetInMegabytes:mapMemoryBudgetInTiles:error:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(setMemoryBudgetMapMemoryBudgetInMegabytes:mapMemoryBudgetInTiles:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTMapMemoryBudgetInMegabytes *arg_mapMemoryBudgetInMegabytes = GetNullableObjectAtIndex(args, 0);
        FLTMapMemoryBudgetInTiles *arg_mapMemoryBudgetInTiles = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api setMemoryBudgetMapMemoryBudgetInMegabytes:arg_mapMemoryBudgetInMegabytes mapMemoryBudgetInTiles:arg_mapMemoryBudgetInTiles error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Gets the size of the map.
  ///
  /// @return The `size` of the map in `logical pixels`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getSize"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getSizeWithError:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(getSizeWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FLTSize *output = [api getSizeWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Triggers a repaint of the map.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.triggerRepaint"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(triggerRepaintWithError:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(triggerRepaintWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api triggerRepaintWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Tells the map rendering engine that there is currently a gesture in progress. This
  /// affects how the map renders labels, as it will use different texture filters if a gesture
  /// is ongoing.
  ///
  /// @param inProgress The `boolean` value representing if a gesture is in progress.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setGestureInProgress"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setGestureInProgressInProgress:error:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(setGestureInProgressInProgress:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSNumber *arg_inProgress = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api setGestureInProgressInProgress:arg_inProgress error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns `true` if a gesture is currently in progress.
  ///
  /// @return `true` if a gesture is currently in progress, `false` otherwise.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.isGestureInProgress"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(isGestureInProgressWithError:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(isGestureInProgressWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api isGestureInProgressWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Tells the map rendering engine that the animation is currently performed by the
  /// user (e.g. with a `setCamera` calls series). It adjusts the engine for the animation use case.
  /// In particular, it brings more stability to symbol placement and rendering.
  ///
  /// @param inProgress The `boolean` value representing if user animation is in progress
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setUserAnimationInProgress"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setUserAnimationInProgressInProgress:error:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(setUserAnimationInProgressInProgress:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSNumber *arg_inProgress = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api setUserAnimationInProgressInProgress:arg_inProgress error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns `true` if user animation is currently in progress.
  ///
  /// @return `true` if a user animation is currently in progress, `false` otherwise.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.isUserAnimationInProgress"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(isUserAnimationInProgressWithError:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(isUserAnimationInProgressWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api isUserAnimationInProgressWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// When loading a map, if prefetch zoom `delta` is set to any number greater than 0,
  /// the map will first request a tile at zoom level lower than `zoom - delta`, with requested
  /// zoom level a multiple of `delta`, in an attempt to display a full map at lower resolution as quick as possible.
  ///
  /// @param delta The new prefetch zoom delta.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setPrefetchZoomDelta"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setPrefetchZoomDeltaDelta:error:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(setPrefetchZoomDeltaDelta:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSNumber *arg_delta = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api setPrefetchZoomDeltaDelta:arg_delta error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the map's prefetch zoom delta.
  ///
  /// @return The map's prefetch zoom `delta`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getPrefetchZoomDelta"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getPrefetchZoomDeltaWithError:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(getPrefetchZoomDeltaWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api getPrefetchZoomDeltaWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets the north `orientation mode`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setNorthOrientation"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setNorthOrientationOrientation:error:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(setNorthOrientationOrientation:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTNorthOrientation arg_orientation = [GetNullableObjectAtIndex(args, 0) integerValue];
        FlutterError *error;
        [api setNorthOrientationOrientation:arg_orientation error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets the map `constrain mode`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setConstrainMode"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setConstrainModeMode:error:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(setConstrainModeMode:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTConstrainMode arg_mode = [GetNullableObjectAtIndex(args, 0) integerValue];
        FlutterError *error;
        [api setConstrainModeMode:arg_mode error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets the `viewport mode`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setViewportMode"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setViewportModeMode:error:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(setViewportModeMode:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTViewportMode arg_mode = [GetNullableObjectAtIndex(args, 0) integerValue];
        FlutterError *error;
        [api setViewportModeMode:arg_mode error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the `map options`.
  ///
  /// @return The map's `map options`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getMapOptions"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getMapOptionsWithError:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(getMapOptionsWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FLTMapOptions *output = [api getMapOptionsWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the `map debug options`.
  ///
  /// @return An array of `map debug options` flags currently set to the map.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getDebug"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getDebugWithError:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(getDebugWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSArray<FLTMapDebugOptions *> *output = [api getDebugWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets the `map debug options` and enables debug mode based on the passed value.
  ///
  /// @param debugOptions An array of `map debug options` to be set.
  /// @param value A `boolean` value representing the state for a given `map debug options`.
  ///
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setDebug"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setDebugDebugOptions:value:error:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(setDebugDebugOptions:value:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSArray<FLTMapDebugOptions *> *arg_debugOptions = GetNullableObjectAtIndex(args, 0);
        NSNumber *arg_value = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api setDebugDebugOptions:arg_debugOptions value:arg_value error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Queries the map for rendered features.
  ///
  /// @param geometry The `screen pixel coordinates` (point, line string or box) to query for rendered features.
  /// @param options The `render query options` for querying rendered features.
  /// @param completion The `query features completion` called when the query completes.
  /// @return A `cancelable` object that could be used to cancel the pending query.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.queryRenderedFeatures"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(queryRenderedFeaturesGeometry:options:completion:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(queryRenderedFeaturesGeometry:options:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTRenderedQueryGeometry *arg_geometry = GetNullableObjectAtIndex(args, 0);
        FLTRenderedQueryOptions *arg_options = GetNullableObjectAtIndex(args, 1);
        [api queryRenderedFeaturesGeometry:arg_geometry options:arg_options completion:^(NSArray<FLTQueriedFeature *> *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Queries the map for source features.
  ///
  /// @param sourceId The style source identifier used to query for source features.
  /// @param options The `source query options` for querying source features.
  /// @param completion The `query features completion` called when the query completes.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.querySourceFeatures"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(querySourceFeaturesSourceId:options:completion:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(querySourceFeaturesSourceId:options:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceId = GetNullableObjectAtIndex(args, 0);
        FLTSourceQueryOptions *arg_options = GetNullableObjectAtIndex(args, 1);
        [api querySourceFeaturesSourceId:arg_sourceId options:arg_options completion:^(NSArray<FLTQueriedFeature *> *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns all the leaves (original points) of a cluster (given its cluster_id) from a GeoJsonSource, with pagination support: limit is the number of leaves
  /// to return (set to Infinity for all points), and offset is the amount of points to skip (for pagination).
  ///
  /// Requires configuring the source as a cluster by calling [GeoJsonSource.Builder#cluster(boolean)].
  ///
  /// @param sourceIdentifier GeoJsonSource identifier.
  /// @param cluster Cluster from which to retrieve leaves from
  /// @param limit The number of points to return from the query (must use type [Long], set to maximum for all points). Defaults to 10.
  /// @param offset The amount of points to skip (for pagination, must use type [Long]). Defaults to 0.
  /// @param completion The result will be returned through the completion block.
  ///         The result is a feature collection or a string describing an error if the operation was not successful.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getGeoJsonClusterLeaves"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getGeoJsonClusterLeavesSourceIdentifier:cluster:limit:offset:completion:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(getGeoJsonClusterLeavesSourceIdentifier:cluster:limit:offset:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceIdentifier = GetNullableObjectAtIndex(args, 0);
        NSDictionary<NSString *, id> *arg_cluster = GetNullableObjectAtIndex(args, 1);
        NSNumber *arg_limit = GetNullableObjectAtIndex(args, 2);
        NSNumber *arg_offset = GetNullableObjectAtIndex(args, 3);
        [api getGeoJsonClusterLeavesSourceIdentifier:arg_sourceIdentifier cluster:arg_cluster limit:arg_limit offset:arg_offset completion:^(FLTFeatureExtensionValue *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the children (original points or clusters) of a cluster (on the next zoom level)
  /// given its id (cluster_id value from feature properties) from a GeoJsonSource.
  ///
  /// Requires configuring the source as a cluster by calling [GeoJsonSource.Builder#cluster(boolean)].
  ///
  /// @param sourceIdentifier GeoJsonSource identifier.
  /// @param cluster cluster from which to retrieve children from
  /// @param completion The result will be returned through the completion block.
  ///         The result is a feature collection or a string describing an error if the operation was not successful.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getGeoJsonClusterChildren"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getGeoJsonClusterChildrenSourceIdentifier:cluster:completion:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(getGeoJsonClusterChildrenSourceIdentifier:cluster:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceIdentifier = GetNullableObjectAtIndex(args, 0);
        NSDictionary<NSString *, id> *arg_cluster = GetNullableObjectAtIndex(args, 1);
        [api getGeoJsonClusterChildrenSourceIdentifier:arg_sourceIdentifier cluster:arg_cluster completion:^(FLTFeatureExtensionValue *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the zoom on which the cluster expands into several children (useful for "click to zoom" feature)
  /// given the cluster's cluster_id (cluster_id value from feature properties) from a GeoJsonSource.
  ///
  /// Requires configuring the source as a cluster by calling [GeoJsonSource.Builder#cluster(boolean)].
  ///
  /// @param sourceIdentifier GeoJsonSource identifier.
  /// @param cluster cluster from which to retrieve the expansion zoom from
  /// @param completion The result will be returned through the completion block.
  ///         The result is a feature extension value containing a value or a string describing an error if the operation was not successful.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getGeoJsonClusterExpansionZoom"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getGeoJsonClusterExpansionZoomSourceIdentifier:cluster:completion:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(getGeoJsonClusterExpansionZoomSourceIdentifier:cluster:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceIdentifier = GetNullableObjectAtIndex(args, 0);
        NSDictionary<NSString *, id> *arg_cluster = GetNullableObjectAtIndex(args, 1);
        [api getGeoJsonClusterExpansionZoomSourceIdentifier:arg_sourceIdentifier cluster:arg_cluster completion:^(FLTFeatureExtensionValue *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Updates the state object of a feature within a style source.
  ///
  /// Update entries in the `state` object of a given feature within a style source. Only properties of the
  /// `state` object will be updated. A property in the feature `state` object that is not listed in `state` will
  /// retain its previous value.
  ///
  /// Note that updates to feature `state` are asynchronous, so changes made by this method migth not be
  /// immediately visible using `getStateFeature`.
  ///
  /// @param sourceId The style source identifier.
  /// @param sourceLayerId The style source layer identifier (for multi-layer sources such as vector sources).
  /// @param featureId The feature identifier of the feature whose state should be updated.
  /// @param state The `state` object with properties to update with their respective new values.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setFeatureState"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setFeatureStateSourceId:sourceLayerId:featureId:state:error:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(setFeatureStateSourceId:sourceLayerId:featureId:state:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_sourceLayerId = GetNullableObjectAtIndex(args, 1);
        NSString *arg_featureId = GetNullableObjectAtIndex(args, 2);
        NSString *arg_state = GetNullableObjectAtIndex(args, 3);
        FlutterError *error;
        [api setFeatureStateSourceId:arg_sourceId sourceLayerId:arg_sourceLayerId featureId:arg_featureId state:arg_state error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Gets the state map of a feature within a style source.
  ///
  /// Note that updates to feature state are asynchronous, so changes made by other methods might not be
  /// immediately visible.
  ///
  /// @param sourceId The style source identifier.
  /// @param sourceLayerId The style source layer identifier (for multi-layer sources such as vector sources).
  /// @param featureId The feature identifier of the feature whose state should be queried.
  /// @param completion The `query feature state completion` called when the query completes.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getFeatureState"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getFeatureStateSourceId:sourceLayerId:featureId:completion:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(getFeatureStateSourceId:sourceLayerId:featureId:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_sourceLayerId = GetNullableObjectAtIndex(args, 1);
        NSString *arg_featureId = GetNullableObjectAtIndex(args, 2);
        [api getFeatureStateSourceId:arg_sourceId sourceLayerId:arg_sourceLayerId featureId:arg_featureId completion:^(NSString *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Removes entries from a feature state object.
  ///
  /// Remove a specified property or all property from a feature's state object, depending on the value of
  /// `stateKey`.
  ///
  /// Note that updates to feature state are asynchronous, so changes made by this method migth not be
  /// immediately visible using `getStateFeature`.
  ///
  /// @param sourceId The style source identifier.
  /// @param sourceLayerId The style source layer identifier (for multi-layer sources such as vector sources).
  /// @param featureId The feature identifier of the feature whose state should be removed.
  /// @param stateKey The key of the property to remove. If `null`, all feature's state object properties are removed.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.removeFeatureState"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(removeFeatureStateSourceId:sourceLayerId:featureId:stateKey:error:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(removeFeatureStateSourceId:sourceLayerId:featureId:stateKey:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_sourceLayerId = GetNullableObjectAtIndex(args, 1);
        NSString *arg_featureId = GetNullableObjectAtIndex(args, 2);
        NSString *arg_stateKey = GetNullableObjectAtIndex(args, 3);
        FlutterError *error;
        [api removeFeatureStateSourceId:arg_sourceId sourceLayerId:arg_sourceLayerId featureId:arg_featureId stateKey:arg_stateKey error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Reduces memory use. Useful to call when the application gets paused or sent to background.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.reduceMemoryUse"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(reduceMemoryUseWithError:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(reduceMemoryUseWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api reduceMemoryUseWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Gets the resource options for the map.
  ///
  /// All optional fields of the retuned object are initialized with the actual values.
  ///
  /// Note that result of this method is different from the `resource options` that were provided to the map's constructor.
  ///
  /// @return The `resource options` for the map.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getResourceOptions"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getResourceOptionsWithError:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(getResourceOptionsWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FLTResourceOptions *output = [api getResourceOptionsWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Gets elevation for the given coordinate.
  /// Note: Elevation is only available for the visible region on the screen.
  ///
  /// @param coordinate The `coordinate` defined as longitude-latitude pair.
  /// @return The elevation (in meters) multiplied by current terrain exaggeration, or empty if elevation for the coordinate is not available.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getElevation"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getElevationCoordinate:error:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(getElevationCoordinate:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSDictionary<NSString *, id> *arg_coordinate = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSNumber *output = [api getElevationCoordinate:arg_coordinate error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FLTOfflineRegionCodecReader : FlutterStandardReader
@end
@implementation FLTOfflineRegionCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [FLTCoordinateBounds fromList:[self readValue]];
    case 129: 
      return [FLTOfflineRegionGeometryDefinition fromList:[self readValue]];
    case 130: 
      return [FLTOfflineRegionTilePyramidDefinition fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface FLTOfflineRegionCodecWriter : FlutterStandardWriter
@end
@implementation FLTOfflineRegionCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[FLTCoordinateBounds class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTOfflineRegionGeometryDefinition class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTOfflineRegionTilePyramidDefinition class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface FLTOfflineRegionCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FLTOfflineRegionCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FLTOfflineRegionCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FLTOfflineRegionCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FLTOfflineRegionGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    FLTOfflineRegionCodecReaderWriter *readerWriter = [[FLTOfflineRegionCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void FLTOfflineRegionSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLTOfflineRegion> *api) {
  /// The regions identifier
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.getIdentifier"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineRegionGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getIdentifierWithError:)], @"FLTOfflineRegion api (%@) doesn't respond to @selector(getIdentifierWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api getIdentifierWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// The tile pyramid defining the region. Tile pyramid and geometry definitions are
  /// mutually exclusive.
  ///
  /// @return A definition describing the tile pyramid including attributes, otherwise empty.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.getTilePyramidDefinition"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineRegionGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getTilePyramidDefinitionWithError:)], @"FLTOfflineRegion api (%@) doesn't respond to @selector(getTilePyramidDefinitionWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FLTOfflineRegionTilePyramidDefinition *output = [api getTilePyramidDefinitionWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// The geometry defining the region. Geometry and tile pyramid definitions are
  /// mutually exclusive.
  ///
  /// @return A definition describing the geometry including attributes, otherwise empty.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.getGeometryDefinition"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineRegionGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getGeometryDefinitionWithError:)], @"FLTOfflineRegion api (%@) doesn't respond to @selector(getGeometryDefinitionWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FLTOfflineRegionGeometryDefinition *output = [api getGeometryDefinitionWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Arbitrary binary region metadata.
  ///
  /// @return The metadata associated with the region.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.getMetadata"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineRegionGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getMetadataWithError:)], @"FLTOfflineRegion api (%@) doesn't respond to @selector(getMetadataWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FlutterStandardTypedData *output = [api getMetadataWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets arbitrary binary region metadata for the region.
  ///
  /// Note that this setter is asynchronous and the given metadata is applied only
  /// after the resulting callback is invoked with no error.
  ///
  /// @param metadata The metadata associated with the region.
  /// @param callback Called once the request is complete or an error occurred.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.setMetadata"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineRegionGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setMetadataMetadata:completion:)], @"FLTOfflineRegion api (%@) doesn't respond to @selector(setMetadataMetadata:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FlutterStandardTypedData *arg_metadata = GetNullableObjectAtIndex(args, 0);
        [api setMetadataMetadata:arg_metadata completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets the download state of an offline region
  /// A region is either inactive (not downloading, but previously-downloaded
  /// resources are available for use), or active (resources are being downloaded
  /// or will be downloaded, if necessary, when network access is available).
  ///
  /// If the region is already in the given state, this call is ignored.
  ///
  /// @param state The new state to set.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.setOfflineRegionDownloadState"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineRegionGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setOfflineRegionDownloadStateState:error:)], @"FLTOfflineRegion api (%@) doesn't respond to @selector(setOfflineRegionDownloadStateState:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTOfflineRegionDownloadState arg_state = [GetNullableObjectAtIndex(args, 0) integerValue];
        FlutterError *error;
        [api setOfflineRegionDownloadStateState:arg_state error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Invalidate all the tiles for the region forcing to revalidate
  /// the tiles with the server before using. This is more efficient than deleting the
  /// offline region and downloading it again because if the data on the cache matches
  /// the server, no new data gets transmitted.
  ///
  /// @param callback Called once the request is complete or an error occurred.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.invalidate"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineRegionGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(invalidateWithCompletion:)], @"FLTOfflineRegion api (%@) doesn't respond to @selector(invalidateWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api invalidateWithCompletion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Remove an offline region from the database and perform any resources
  /// evictions necessary as a result.
  ///
  /// @param callback Called once the request is complete or an error occurred.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.purge"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineRegionGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(purgeWithCompletion:)], @"FLTOfflineRegion api (%@) doesn't respond to @selector(purgeWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api purgeWithCompletion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
NSObject<FlutterMessageCodec> *FLTOfflineRegionManagerGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  sSharedObject = [FlutterStandardMessageCodec sharedInstance];
  return sSharedObject;
}

void FLTOfflineRegionManagerSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLTOfflineRegionManager> *api) {
  /// Sets the maximum number of Mapbox-hosted tiles that may be downloaded and stored on the current device.
  ///
  /// By default, the limit is set to 6,000.
  /// Once this limit is reached, `OfflineRegionObserver.mapboxTileCountLimitExceeded()`
  /// fires every additional attempt to download additional tiles until already downloaded tiles are removed
  /// by calling `OfflineRegion.purge()` API.
  ///
  /// @param limit the maximum number of tiles allowed to be downloaded
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegionManager.setOfflineMapboxTileCountLimit"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineRegionManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setOfflineMapboxTileCountLimitLimit:error:)], @"FLTOfflineRegionManager api (%@) doesn't respond to @selector(setOfflineMapboxTileCountLimitLimit:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSNumber *arg_limit = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api setOfflineMapboxTileCountLimitLimit:arg_limit error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FLTProjectionCodecReader : FlutterStandardReader
@end
@implementation FLTProjectionCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [FLTCameraBounds fromList:[self readValue]];
    case 129: 
      return [FLTCameraBoundsOptions fromList:[self readValue]];
    case 130: 
      return [FLTCameraOptions fromList:[self readValue]];
    case 131: 
      return [FLTCameraState fromList:[self readValue]];
    case 132: 
      return [FLTCanonicalTileID fromList:[self readValue]];
    case 133: 
      return [FLTCoordinateBounds fromList:[self readValue]];
    case 134: 
      return [FLTCoordinateBoundsZoom fromList:[self readValue]];
    case 135: 
      return [FLTFeatureExtensionValue fromList:[self readValue]];
    case 136: 
      return [FLTGlyphsRasterizationOptions fromList:[self readValue]];
    case 137: 
      return [FLTImageContent fromList:[self readValue]];
    case 138: 
      return [FLTImageStretches fromList:[self readValue]];
    case 139: 
      return [FLTLayerPosition fromList:[self readValue]];
    case 140: 
      return [FLTMapAnimationOptions fromList:[self readValue]];
    case 141: 
      return [FLTMapDebugOptions fromList:[self readValue]];
    case 142: 
      return [FLTMapMemoryBudgetInMegabytes fromList:[self readValue]];
    case 143: 
      return [FLTMapMemoryBudgetInTiles fromList:[self readValue]];
    case 144: 
      return [FLTMapOptions fromList:[self readValue]];
    case 145: 
      return [FLTMbxEdgeInsets fromList:[self readValue]];
    case 146: 
      return [FLTMbxImage fromList:[self readValue]];
    case 147: 
      return [FLTMercatorCoordinate fromList:[self readValue]];
    case 148: 
      return [FLTOfflineRegionGeometryDefinition fromList:[self readValue]];
    case 149: 
      return [FLTOfflineRegionTilePyramidDefinition fromList:[self readValue]];
    case 150: 
      return [FLTProjectedMeters fromList:[self readValue]];
    case 151: 
      return [FLTQueriedFeature fromList:[self readValue]];
    case 152: 
      return [FLTRenderedQueryGeometry fromList:[self readValue]];
    case 153: 
      return [FLTRenderedQueryOptions fromList:[self readValue]];
    case 154: 
      return [FLTResourceOptions fromList:[self readValue]];
    case 155: 
      return [FLTScreenBox fromList:[self readValue]];
    case 156: 
      return [FLTScreenCoordinate fromList:[self readValue]];
    case 157: 
      return [FLTSize fromList:[self readValue]];
    case 158: 
      return [FLTSourceQueryOptions fromList:[self readValue]];
    case 159: 
      return [FLTStyleObjectInfo fromList:[self readValue]];
    case 160: 
      return [FLTStylePropertyValue fromList:[self readValue]];
    case 161: 
      return [FLTTransitionOptions fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface FLTProjectionCodecWriter : FlutterStandardWriter
@end
@implementation FLTProjectionCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[FLTCameraBounds class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraBoundsOptions class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraOptions class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraState class]]) {
    [self writeByte:131];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCanonicalTileID class]]) {
    [self writeByte:132];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCoordinateBounds class]]) {
    [self writeByte:133];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCoordinateBoundsZoom class]]) {
    [self writeByte:134];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTFeatureExtensionValue class]]) {
    [self writeByte:135];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTGlyphsRasterizationOptions class]]) {
    [self writeByte:136];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTImageContent class]]) {
    [self writeByte:137];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTImageStretches class]]) {
    [self writeByte:138];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTLayerPosition class]]) {
    [self writeByte:139];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapAnimationOptions class]]) {
    [self writeByte:140];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapDebugOptions class]]) {
    [self writeByte:141];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapMemoryBudgetInMegabytes class]]) {
    [self writeByte:142];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapMemoryBudgetInTiles class]]) {
    [self writeByte:143];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapOptions class]]) {
    [self writeByte:144];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMbxEdgeInsets class]]) {
    [self writeByte:145];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMbxImage class]]) {
    [self writeByte:146];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMercatorCoordinate class]]) {
    [self writeByte:147];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTOfflineRegionGeometryDefinition class]]) {
    [self writeByte:148];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTOfflineRegionTilePyramidDefinition class]]) {
    [self writeByte:149];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTProjectedMeters class]]) {
    [self writeByte:150];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTQueriedFeature class]]) {
    [self writeByte:151];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTRenderedQueryGeometry class]]) {
    [self writeByte:152];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTRenderedQueryOptions class]]) {
    [self writeByte:153];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTResourceOptions class]]) {
    [self writeByte:154];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTScreenBox class]]) {
    [self writeByte:155];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTScreenCoordinate class]]) {
    [self writeByte:156];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTSize class]]) {
    [self writeByte:157];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTSourceQueryOptions class]]) {
    [self writeByte:158];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTStyleObjectInfo class]]) {
    [self writeByte:159];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTStylePropertyValue class]]) {
    [self writeByte:160];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTTransitionOptions class]]) {
    [self writeByte:161];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface FLTProjectionCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FLTProjectionCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FLTProjectionCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FLTProjectionCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FLTProjectionGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    FLTProjectionCodecReaderWriter *readerWriter = [[FLTProjectionCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void FLTProjectionSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLTProjection> *api) {
  /// Calculate distance spanned by one pixel at the specified latitude
  /// and zoom level.
  ///
  /// @param latitude The latitude for which to return the value.
  /// @param zoom The zoom level.
  ///
  /// @return Returns the distance measured in meters.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.Projection.getMetersPerPixelAtLatitude"
        binaryMessenger:binaryMessenger
        codec:FLTProjectionGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getMetersPerPixelAtLatitudeLatitude:zoom:error:)], @"FLTProjection api (%@) doesn't respond to @selector(getMetersPerPixelAtLatitudeLatitude:zoom:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSNumber *arg_latitude = GetNullableObjectAtIndex(args, 0);
        NSNumber *arg_zoom = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        NSNumber *output = [api getMetersPerPixelAtLatitudeLatitude:arg_latitude zoom:arg_zoom error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Calculate Spherical Mercator ProjectedMeters coordinates.
  ///
  /// @param coordinate A longitude-latitude pair for which to calculate
  /// `projected meters` coordinates.
  ///
  /// @return Returns Spherical Mercator ProjectedMeters coordinates.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.Projection.projectedMetersForCoordinate"
        binaryMessenger:binaryMessenger
        codec:FLTProjectionGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(projectedMetersForCoordinateCoordinate:error:)], @"FLTProjection api (%@) doesn't respond to @selector(projectedMetersForCoordinateCoordinate:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSDictionary<NSString *, id> *arg_coordinate = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        FLTProjectedMeters *output = [api projectedMetersForCoordinateCoordinate:arg_coordinate error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Calculate a longitude-latitude pair for a Spherical Mercator projected
  /// meters.
  ///
  /// @param projectedMeters Spherical Mercator ProjectedMeters coordinates for
  /// which to calculate a longitude-latitude pair.
  ///
  /// @return Returns a longitude-latitude pair.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.Projection.coordinateForProjectedMeters"
        binaryMessenger:binaryMessenger
        codec:FLTProjectionGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(coordinateForProjectedMetersProjectedMeters:error:)], @"FLTProjection api (%@) doesn't respond to @selector(coordinateForProjectedMetersProjectedMeters:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTProjectedMeters *arg_projectedMeters = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSDictionary<NSString *, id> *output = [api coordinateForProjectedMetersProjectedMeters:arg_projectedMeters error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Calculate a point on the map in Mercator Projection for a given
  /// coordinate at the specified zoom scale.
  ///
  /// @param coordinate The longitude-latitude pair for which to return the value.
  /// @param zoomScale The current zoom factor (2 ^ Zoom level) applied on the map, is used to
  /// calculate the world size as tileSize * zoomScale (i.e., 512 * 2 ^ Zoom level)
  /// where tileSize is the width of a tile in pixels.
  ///
  /// @return Returns a point on the map in Mercator projection.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.Projection.project"
        binaryMessenger:binaryMessenger
        codec:FLTProjectionGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(projectCoordinate:zoomScale:error:)], @"FLTProjection api (%@) doesn't respond to @selector(projectCoordinate:zoomScale:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSDictionary<NSString *, id> *arg_coordinate = GetNullableObjectAtIndex(args, 0);
        NSNumber *arg_zoomScale = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        FLTMercatorCoordinate *output = [api projectCoordinate:arg_coordinate zoomScale:arg_zoomScale error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Calculate a coordinate for a given point on the map in Mercator Projection.
  ///
  /// @param coordinate Point on the map in Mercator projection.
  /// @param zoomScale The current zoom factor applied on the map, is used to
  /// calculate the world size as tileSize * zoomScale (i.e., 512 * 2 ^ Zoom level)
  /// where tileSize is the width of a tile in pixels.
  ///
  /// @return Returns a coordinate.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.Projection.unproject"
        binaryMessenger:binaryMessenger
        codec:FLTProjectionGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(unprojectCoordinate:zoomScale:error:)], @"FLTProjection api (%@) doesn't respond to @selector(unprojectCoordinate:zoomScale:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTMercatorCoordinate *arg_coordinate = GetNullableObjectAtIndex(args, 0);
        NSNumber *arg_zoomScale = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        NSDictionary<NSString *, id> *output = [api unprojectCoordinate:arg_coordinate zoomScale:arg_zoomScale error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
NSObject<FlutterMessageCodec> *FLTSettingsGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  sSharedObject = [FlutterStandardMessageCodec sharedInstance];
  return sSharedObject;
}

void FLTSettingsSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLTSettings> *api) {
  /// Sets setting value for a specified key.
  ///
  /// @param key A name of the key.
  /// @param value The `value` for the key.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.Settings.set"
        binaryMessenger:binaryMessenger
        codec:FLTSettingsGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setKey:value:error:)], @"FLTSettings api (%@) doesn't respond to @selector(setKey:value:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_key = GetNullableObjectAtIndex(args, 0);
        NSString *arg_value = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api setKey:arg_key value:arg_value error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Return value for a key.
  ///
  /// @param key A name of the key.
  ///
  /// @return `value` if a key exists in settings otherwise a `null value` will be returned.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.Settings.get"
        binaryMessenger:binaryMessenger
        codec:FLTSettingsGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getKey:error:)], @"FLTSettings api (%@) doesn't respond to @selector(getKey:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_key = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSString *output = [api getKey:arg_key error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FLTMapSnapshotCodecReader : FlutterStandardReader
@end
@implementation FLTMapSnapshotCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [FLTCameraBounds fromList:[self readValue]];
    case 129: 
      return [FLTCameraBoundsOptions fromList:[self readValue]];
    case 130: 
      return [FLTCameraOptions fromList:[self readValue]];
    case 131: 
      return [FLTCameraState fromList:[self readValue]];
    case 132: 
      return [FLTCanonicalTileID fromList:[self readValue]];
    case 133: 
      return [FLTCoordinateBounds fromList:[self readValue]];
    case 134: 
      return [FLTCoordinateBoundsZoom fromList:[self readValue]];
    case 135: 
      return [FLTFeatureExtensionValue fromList:[self readValue]];
    case 136: 
      return [FLTGlyphsRasterizationOptions fromList:[self readValue]];
    case 137: 
      return [FLTImageContent fromList:[self readValue]];
    case 138: 
      return [FLTImageStretches fromList:[self readValue]];
    case 139: 
      return [FLTLayerPosition fromList:[self readValue]];
    case 140: 
      return [FLTMapAnimationOptions fromList:[self readValue]];
    case 141: 
      return [FLTMapDebugOptions fromList:[self readValue]];
    case 142: 
      return [FLTMapMemoryBudgetInMegabytes fromList:[self readValue]];
    case 143: 
      return [FLTMapMemoryBudgetInTiles fromList:[self readValue]];
    case 144: 
      return [FLTMapOptions fromList:[self readValue]];
    case 145: 
      return [FLTMbxEdgeInsets fromList:[self readValue]];
    case 146: 
      return [FLTMbxImage fromList:[self readValue]];
    case 147: 
      return [FLTMercatorCoordinate fromList:[self readValue]];
    case 148: 
      return [FLTOfflineRegionGeometryDefinition fromList:[self readValue]];
    case 149: 
      return [FLTOfflineRegionTilePyramidDefinition fromList:[self readValue]];
    case 150: 
      return [FLTProjectedMeters fromList:[self readValue]];
    case 151: 
      return [FLTQueriedFeature fromList:[self readValue]];
    case 152: 
      return [FLTRenderedQueryGeometry fromList:[self readValue]];
    case 153: 
      return [FLTRenderedQueryOptions fromList:[self readValue]];
    case 154: 
      return [FLTResourceOptions fromList:[self readValue]];
    case 155: 
      return [FLTScreenBox fromList:[self readValue]];
    case 156: 
      return [FLTScreenCoordinate fromList:[self readValue]];
    case 157: 
      return [FLTSize fromList:[self readValue]];
    case 158: 
      return [FLTSourceQueryOptions fromList:[self readValue]];
    case 159: 
      return [FLTStyleObjectInfo fromList:[self readValue]];
    case 160: 
      return [FLTStylePropertyValue fromList:[self readValue]];
    case 161: 
      return [FLTTransitionOptions fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface FLTMapSnapshotCodecWriter : FlutterStandardWriter
@end
@implementation FLTMapSnapshotCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[FLTCameraBounds class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraBoundsOptions class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraOptions class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraState class]]) {
    [self writeByte:131];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCanonicalTileID class]]) {
    [self writeByte:132];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCoordinateBounds class]]) {
    [self writeByte:133];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCoordinateBoundsZoom class]]) {
    [self writeByte:134];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTFeatureExtensionValue class]]) {
    [self writeByte:135];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTGlyphsRasterizationOptions class]]) {
    [self writeByte:136];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTImageContent class]]) {
    [self writeByte:137];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTImageStretches class]]) {
    [self writeByte:138];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTLayerPosition class]]) {
    [self writeByte:139];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapAnimationOptions class]]) {
    [self writeByte:140];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapDebugOptions class]]) {
    [self writeByte:141];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapMemoryBudgetInMegabytes class]]) {
    [self writeByte:142];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapMemoryBudgetInTiles class]]) {
    [self writeByte:143];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapOptions class]]) {
    [self writeByte:144];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMbxEdgeInsets class]]) {
    [self writeByte:145];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMbxImage class]]) {
    [self writeByte:146];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMercatorCoordinate class]]) {
    [self writeByte:147];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTOfflineRegionGeometryDefinition class]]) {
    [self writeByte:148];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTOfflineRegionTilePyramidDefinition class]]) {
    [self writeByte:149];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTProjectedMeters class]]) {
    [self writeByte:150];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTQueriedFeature class]]) {
    [self writeByte:151];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTRenderedQueryGeometry class]]) {
    [self writeByte:152];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTRenderedQueryOptions class]]) {
    [self writeByte:153];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTResourceOptions class]]) {
    [self writeByte:154];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTScreenBox class]]) {
    [self writeByte:155];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTScreenCoordinate class]]) {
    [self writeByte:156];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTSize class]]) {
    [self writeByte:157];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTSourceQueryOptions class]]) {
    [self writeByte:158];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTStyleObjectInfo class]]) {
    [self writeByte:159];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTStylePropertyValue class]]) {
    [self writeByte:160];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTTransitionOptions class]]) {
    [self writeByte:161];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface FLTMapSnapshotCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FLTMapSnapshotCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FLTMapSnapshotCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FLTMapSnapshotCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FLTMapSnapshotGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    FLTMapSnapshotCodecReaderWriter *readerWriter = [[FLTMapSnapshotCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void FLTMapSnapshotSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLTMapSnapshot> *api) {
  /// Calculate screen coordinate on the snapshot from geographical `coordinate`.
  ///
  /// @param coordinate A geographical `coordinate`.
  /// @return A `screen coordinate` measured in `logical pixels` on the snapshot for geographical `coordinate`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshot.screenCoordinate"
        binaryMessenger:binaryMessenger
        codec:FLTMapSnapshotGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(screenCoordinateCoordinate:error:)], @"FLTMapSnapshot api (%@) doesn't respond to @selector(screenCoordinateCoordinate:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSDictionary<NSString *, id> *arg_coordinate = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        FLTScreenCoordinate *output = [api screenCoordinateCoordinate:arg_coordinate error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Calculate geographical coordinates from a point on the snapshot.
  ///
  /// @param screenCoordinate A `screen coordinate` on the snapshot in `logical pixels`.
  /// @return A geographical `coordinate` for a `screen coordinate` on the snapshot.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshot.coordinate"
        binaryMessenger:binaryMessenger
        codec:FLTMapSnapshotGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(coordinateScreenCoordinate:error:)], @"FLTMapSnapshot api (%@) doesn't respond to @selector(coordinateScreenCoordinate:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTScreenCoordinate *arg_screenCoordinate = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSDictionary<NSString *, id> *output = [api coordinateScreenCoordinate:arg_screenCoordinate error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Get list of attributions for the sources in this snapshot.
  ///
  /// @return A list of attributions for the sources in this snapshot.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshot.attributions"
        binaryMessenger:binaryMessenger
        codec:FLTMapSnapshotGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(attributionsWithError:)], @"FLTMapSnapshot api (%@) doesn't respond to @selector(attributionsWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSArray<NSString *> *output = [api attributionsWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Get the rendered snapshot `image`.
  ///
  /// @return A rendered snapshot `image`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshot.image"
        binaryMessenger:binaryMessenger
        codec:FLTMapSnapshotGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(imageWithError:)], @"FLTMapSnapshot api (%@) doesn't respond to @selector(imageWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FLTMbxImage *output = [api imageWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FLTMapSnapshotterCodecReader : FlutterStandardReader
@end
@implementation FLTMapSnapshotterCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [FLTCameraBounds fromList:[self readValue]];
    case 129: 
      return [FLTCameraBoundsOptions fromList:[self readValue]];
    case 130: 
      return [FLTCameraOptions fromList:[self readValue]];
    case 131: 
      return [FLTCameraState fromList:[self readValue]];
    case 132: 
      return [FLTCanonicalTileID fromList:[self readValue]];
    case 133: 
      return [FLTCoordinateBounds fromList:[self readValue]];
    case 134: 
      return [FLTCoordinateBoundsZoom fromList:[self readValue]];
    case 135: 
      return [FLTFeatureExtensionValue fromList:[self readValue]];
    case 136: 
      return [FLTGlyphsRasterizationOptions fromList:[self readValue]];
    case 137: 
      return [FLTImageContent fromList:[self readValue]];
    case 138: 
      return [FLTImageStretches fromList:[self readValue]];
    case 139: 
      return [FLTLayerPosition fromList:[self readValue]];
    case 140: 
      return [FLTMapAnimationOptions fromList:[self readValue]];
    case 141: 
      return [FLTMapDebugOptions fromList:[self readValue]];
    case 142: 
      return [FLTMapMemoryBudgetInMegabytes fromList:[self readValue]];
    case 143: 
      return [FLTMapMemoryBudgetInTiles fromList:[self readValue]];
    case 144: 
      return [FLTMapOptions fromList:[self readValue]];
    case 145: 
      return [FLTMbxEdgeInsets fromList:[self readValue]];
    case 146: 
      return [FLTMbxImage fromList:[self readValue]];
    case 147: 
      return [FLTMercatorCoordinate fromList:[self readValue]];
    case 148: 
      return [FLTOfflineRegionGeometryDefinition fromList:[self readValue]];
    case 149: 
      return [FLTOfflineRegionTilePyramidDefinition fromList:[self readValue]];
    case 150: 
      return [FLTProjectedMeters fromList:[self readValue]];
    case 151: 
      return [FLTQueriedFeature fromList:[self readValue]];
    case 152: 
      return [FLTRenderedQueryGeometry fromList:[self readValue]];
    case 153: 
      return [FLTRenderedQueryOptions fromList:[self readValue]];
    case 154: 
      return [FLTResourceOptions fromList:[self readValue]];
    case 155: 
      return [FLTScreenBox fromList:[self readValue]];
    case 156: 
      return [FLTScreenCoordinate fromList:[self readValue]];
    case 157: 
      return [FLTSize fromList:[self readValue]];
    case 158: 
      return [FLTSourceQueryOptions fromList:[self readValue]];
    case 159: 
      return [FLTStyleObjectInfo fromList:[self readValue]];
    case 160: 
      return [FLTStylePropertyValue fromList:[self readValue]];
    case 161: 
      return [FLTTransitionOptions fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface FLTMapSnapshotterCodecWriter : FlutterStandardWriter
@end
@implementation FLTMapSnapshotterCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[FLTCameraBounds class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraBoundsOptions class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraOptions class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraState class]]) {
    [self writeByte:131];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCanonicalTileID class]]) {
    [self writeByte:132];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCoordinateBounds class]]) {
    [self writeByte:133];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCoordinateBoundsZoom class]]) {
    [self writeByte:134];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTFeatureExtensionValue class]]) {
    [self writeByte:135];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTGlyphsRasterizationOptions class]]) {
    [self writeByte:136];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTImageContent class]]) {
    [self writeByte:137];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTImageStretches class]]) {
    [self writeByte:138];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTLayerPosition class]]) {
    [self writeByte:139];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapAnimationOptions class]]) {
    [self writeByte:140];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapDebugOptions class]]) {
    [self writeByte:141];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapMemoryBudgetInMegabytes class]]) {
    [self writeByte:142];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapMemoryBudgetInTiles class]]) {
    [self writeByte:143];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapOptions class]]) {
    [self writeByte:144];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMbxEdgeInsets class]]) {
    [self writeByte:145];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMbxImage class]]) {
    [self writeByte:146];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMercatorCoordinate class]]) {
    [self writeByte:147];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTOfflineRegionGeometryDefinition class]]) {
    [self writeByte:148];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTOfflineRegionTilePyramidDefinition class]]) {
    [self writeByte:149];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTProjectedMeters class]]) {
    [self writeByte:150];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTQueriedFeature class]]) {
    [self writeByte:151];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTRenderedQueryGeometry class]]) {
    [self writeByte:152];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTRenderedQueryOptions class]]) {
    [self writeByte:153];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTResourceOptions class]]) {
    [self writeByte:154];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTScreenBox class]]) {
    [self writeByte:155];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTScreenCoordinate class]]) {
    [self writeByte:156];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTSize class]]) {
    [self writeByte:157];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTSourceQueryOptions class]]) {
    [self writeByte:158];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTStyleObjectInfo class]]) {
    [self writeByte:159];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTStylePropertyValue class]]) {
    [self writeByte:160];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTTransitionOptions class]]) {
    [self writeByte:161];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface FLTMapSnapshotterCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FLTMapSnapshotterCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FLTMapSnapshotterCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FLTMapSnapshotterCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FLTMapSnapshotterGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    FLTMapSnapshotterCodecReaderWriter *readerWriter = [[FLTMapSnapshotterCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void FLTMapSnapshotterSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLTMapSnapshotter> *api) {
  /// Sets the `size` of the snapshot
  ///
  /// @param size The new `size` of the snapshot in `logical pixels`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshotter.setSize"
        binaryMessenger:binaryMessenger
        codec:FLTMapSnapshotterGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setSizeSize:error:)], @"FLTMapSnapshotter api (%@) doesn't respond to @selector(setSizeSize:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTSize *arg_size = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api setSizeSize:arg_size error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Gets the size of the snapshot
  ///
  /// @return Snapshot `size` in `logical pixels`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshotter.getSize"
        binaryMessenger:binaryMessenger
        codec:FLTMapSnapshotterGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getSizeWithError:)], @"FLTMapSnapshotter api (%@) doesn't respond to @selector(getSizeWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FLTSize *output = [api getSizeWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns `true` if the snapshotter is in the tile mode.
  ///
  /// @return `true` if the snapshotter is in the tile mode, `false` otherwise.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshotter.isInTileMode"
        binaryMessenger:binaryMessenger
        codec:FLTMapSnapshotterGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(isInTileModeWithError:)], @"FLTMapSnapshotter api (%@) doesn't respond to @selector(isInTileModeWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api isInTileModeWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets the snapshotter to the tile mode.
  ///
  /// In the tile mode, the snapshotter fetches the still image of a single tile.
  ///
  /// @param set A `boolean` value representing if the snapshotter is in the tile mode.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshotter.setTileMode"
        binaryMessenger:binaryMessenger
        codec:FLTMapSnapshotterGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setTileModeSet:error:)], @"FLTMapSnapshotter api (%@) doesn't respond to @selector(setTileModeSet:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSNumber *arg_set = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api setTileModeSet:arg_set error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Cancel the current snapshot operation.
  ///
  /// Cancel the current snapshot operation, if any. The callback passed to the start method
  /// is called with error parameter set.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshotter.cancel"
        binaryMessenger:binaryMessenger
        codec:FLTMapSnapshotterGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(cancelWithError:)], @"FLTMapSnapshotter api (%@) doesn't respond to @selector(cancelWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api cancelWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Get elevation for the given coordinate.
  /// Note: Elevation is only available for the visible region on the screen.
  ///
  /// @param coordinate defined as longitude-latitude pair.
  ///
  /// @return Elevation (in meters) multiplied by current terrain exaggeration, or empty if elevation for the coordinate is not available.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshotter.getElevation"
        binaryMessenger:binaryMessenger
        codec:FLTMapSnapshotterGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getElevationCoordinate:error:)], @"FLTMapSnapshotter api (%@) doesn't respond to @selector(getElevationCoordinate:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSDictionary<NSString *, id> *arg_coordinate = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSNumber *output = [api getElevationCoordinate:arg_coordinate error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}

NSObject<FlutterMessageCodec> *FLTCancelableGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  sSharedObject = [FlutterStandardMessageCodec sharedInstance];
  return sSharedObject;
}

void FLTCancelableSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLTCancelable> *api) {
  /// Cancels the associated asynchronous operation
  ///
  /// If the associated asynchronous operation has already finished, this call is ignored.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.Cancelable.cancel"
        binaryMessenger:binaryMessenger
        codec:FLTCancelableGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(cancelWithError:)], @"FLTCancelable api (%@) doesn't respond to @selector(cancelWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api cancelWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
NSObject<FlutterMessageCodec> *FLTOfflineSwitchGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  sSharedObject = [FlutterStandardMessageCodec sharedInstance];
  return sSharedObject;
}

void FLTOfflineSwitchSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLTOfflineSwitch> *api) {
  /// Connects or disconnects the Mapbox stack. If set to false, current and new HTTP requests will fail
  /// with HttpRequestErrorType#ConnectionError.
  ///
  /// @param connected Set false to disconnect the Mapbox stack
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.OfflineSwitch.setMapboxStackConnected"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineSwitchGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setMapboxStackConnectedConnected:error:)], @"FLTOfflineSwitch api (%@) doesn't respond to @selector(setMapboxStackConnectedConnected:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSNumber *arg_connected = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api setMapboxStackConnectedConnected:arg_connected error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Provides information if the Mapbox stack is connected or disconnected via OfflineSwitch.
  ///
  /// @return True if the Mapbox stack is disconnected via setMapboxStackConnected(), false otherwise.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.OfflineSwitch.isMapboxStackConnected"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineSwitchGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(isMapboxStackConnectedWithError:)], @"FLTOfflineSwitch api (%@) doesn't respond to @selector(isMapboxStackConnectedWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api isMapboxStackConnectedWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Releases the OfflineSwitch singleton instance.
  ///
  /// Users can call this method if they want to do manual cleanup of the resources allocated by Mapbox services.
  /// If the user calls getInstance() after reset, a new instance of the OfflineSwitch singleton will be allocated.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.OfflineSwitch.reset"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineSwitchGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(resetWithError:)], @"FLTOfflineSwitch api (%@) doesn't respond to @selector(resetWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api resetWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
NSObject<FlutterMessageCodec> *FLTTilesetDescriptorGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  sSharedObject = [FlutterStandardMessageCodec sharedInstance];
  return sSharedObject;
}

void FLTTilesetDescriptorSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLTTilesetDescriptor> *api) {
}
